<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>NATO Med Interop Demo — Real-time Facility Routing</title>

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet.vectorgrid@1.3.0/dist/Leaflet.VectorGrid.bundled.js"></script>
  <script src="https://unpkg.com/leaflet-polylinedecorator/dist/leaflet.polylineDecorator.js"></script>

  <style>
    html, body { height: 100%; margin: 0; }
    #map { height: 100%; width: 100%; }

    /* Sidebar */
    .sidebar {
      position: absolute;
      top: 10px; left: 10px;
      z-index: 1000;
      width: 360px;
      max-width: calc(100vw - 20px);
      background: rgba(255,255,255,0.97);
      border-radius: 12px;
      box-shadow: 0 10px 26px rgba(0,0,0,0.18);
      font: 14px/1.25 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      overflow: hidden;
    }
    .sidebar header{
      padding: 10px 12px;
      border-bottom: 1px solid rgba(0,0,0,0.08);
      display:flex;
      gap:10px;
      align-items:baseline;
      justify-content:space-between;
    }
    .sidebar header b { font-size: 15px; }
    .sidebar header small { opacity: 0.75; }
    .sidebar .content { padding: 10px 12px; }
    .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .row + .row { margin-top: 10px; }
    button {
      appearance: none;
      border: 1px solid rgba(0,0,0,0.15);
      background: #fff;
      border-radius: 10px;
      padding: 8px 10px;
      cursor: pointer;
      box-shadow: 0 3px 10px rgba(0,0,0,0.08);
      font-weight: 650;
    }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    .pill {
      border: 1px solid rgba(0,0,0,0.14);
      border-radius: 999px;
      padding: 4px 8px;
      background: rgba(0,0,0,0.03);
      font-size: 12px;
    }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    .hr { height:1px; background: rgba(0,0,0,0.08); margin: 10px 0; }

    .kv { margin: 2px 0; }
    .k { font-weight: 700; }
    input[type="number"]{ width: 90px; padding: 6px 8px; border-radius: 10px; border: 1px solid rgba(0,0,0,0.15); }
    label { cursor: pointer; }

    .status-ok { color: #0a7; font-weight: 700;}
    .status-warn { color: #b60; font-weight: 700;}

    /* Slider specific styling */
    .slider-row { width: 100%; display: flex; flex-direction: column; gap: 4px; }
    #searchBuffer { width: 100%; cursor: pointer; }

    /* Icon Styling */
    .custom-man-icon { background: none; border: none; }
  </style>
</head>

<body>
  <div class="sidebar">
    <header>
      <div>
        <b>Medical Resource Exchange — Demo</b><br/>
        <small>Goal: “right patient → right facility → right time”</small>
      </div>
      <div class="pill mono" id="hsStatus">healthsites: ?</div>
    </header>

    <div class="content">
      <div class="row">
        <button id="btnReset" title="Reset facility availability to baseline">Reset Environment</button>
      </div>

      <div class="row">
        <span class="pill"><input id="triRed" type="checkbox" checked /> <label id="lblRed" style="cursor:pointer; user-select:none;">Immediate (Red)</label></span>
        <span class="pill"><input id="triYellow" type="checkbox" checked /> <label id="lblYellow" style="cursor:pointer; user-select:none;">Delayed (Yellow)</label></span>
        <span class="pill"><input id="triGreen" type="checkbox" checked /> <label id="lblGreen" style="cursor:pointer; user-select:none;">Minimal (Green)</label></span>
      </div>

      <div class="row">
        <label class="pill">Max Travel Distance [km] <input id="maxKm" type="number" value="350" min="10" max="2000"></label>
      </div>
      
      <div class="row slider-row">
        <label class="pill">
          Search Radius: <b id="radiusDisplay">1.5</b>° 
          <input id="searchBuffer" type="range" step="0.1" value="1.5" min="0.5" max="10.0">
        </label>
      </div>

      <div class="row">
        <button id="btnRoute">Run MASCAL Routing</button>
        <span class="pill"><input id="showRoutes" type="checkbox" checked /> <label for="showRoutes">Show routes</label></span>
        <span class="pill"><input id="hideUnused" type="checkbox" /> <label for="hideUnused">Hide unused</label></span>
      </div>

      <div class="hr"></div>

      <div id="summary">
        <div class="kv"><span class="k">Hospitals in Radius:</span> <span id="facCount">–</span></div>
        <div class="kv"><span class="k">Casualties:</span> <span id="caseCount">–</span></div>
        <div class="kv"><span class="k">Routing Result:</span> <span id="routeSummary">Ready</span></div>
      </div>

      <div class="hr"></div>

      <div style="opacity:0.85; font-size:12px;">
        <div class="kv"><span class="k">Note:</span> Pre-loads up to 10° on startup. Adjust slider for real-time visualization.</div>
      </div>
    </div>
  </div>

  <div id="map"></div>

  <script>
    // --- TUNABLE VARIABLE ---
    const MAX_LOAD_RADIUS = 10.0; 

    const map = L.map('map', { 
      center: [56.9, 23.7], 
      zoom: 7, 
      preferCanvas: true, // Uses HTML5 Canvas for high performance
      zoomControl: false
    });

    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19, 
      attribution: '&copy; OpenStreetMap contributors',
      updateWhenIdle: false, // Loads tiles immediately while panning
      keepBuffer: 10         // Keeps more tiles loaded outside the visible view
    }).addTo(map);

    // Using FeatureGroup instead of LayerGroup gives us bringToFront() and bringToBack() for canvas ordering
    const demoRoutesLayer = L.featureGroup().addTo(map);
    const demoFacilitiesLayer = L.featureGroup().addTo(map);
    const demoCasesLayer = L.featureGroup().addTo(map);

    let healthsitesWays = null;
    let healthsitesNodes = null;
    
    // Client-side Data Cache
    let allFacilitiesFeatures = []; 
    let currentCases = [];
    let currentRoutes = [];
    let casualtyBounds = null; 
    let assignedFacilityIds = new Set(); 
    let assignedPatientsByFacility = {}; 

    // Helper function to strictly enforce the Z-Order on the Canvas
    function enforceZOrder() {
        if (map.hasLayer(demoRoutesLayer)) demoRoutesLayer.bringToBack();
        if (map.hasLayer(demoFacilitiesLayer)) demoFacilitiesLayer.bringToFront();
        if (map.hasLayer(demoCasesLayer)) demoCasesLayer.bringToFront(); // Cases always on top
    }

    function triageColor(triage) {
      const t = (triage || "").toLowerCase();
      if (t.includes("red") || t.includes("immediate")) return "#d33";
      if (t.includes("yellow") || t.includes("delayed")) return "#d9a300";
      return "#2a7";
    }

    function facilityColor(bedsAvailable, bedsTotal) {
      const tot = Math.max(1, Number(bedsTotal || 1));
      const av = Math.max(0, Number(bedsAvailable || 0));
      const ratio = av / tot;
      if (ratio <= 0.05) return "#b11";
      if (ratio <= 0.15) return "#b60";
      if (ratio <= 0.30) return "#c9b200";
      return "#0a7";
    }

    function facilityRadius(role, zoom) {
      const r = (role || "").toLowerCase();
      let baseSize = 2; 
      if (r.includes("role4")) baseSize = 5; 
      else if (r.includes("role3")) baseSize = 3; 
      else if (r.includes("role2")) baseSize = 2; 

      return Math.max(0.5, baseSize * Math.pow(1.15, zoom - 7));
    }

    function getManIcon(color, size) {
      return L.divIcon({
        className: 'custom-man-icon',
        html: `<svg viewBox="0 0 960 960" width="${size}" height="${size}">
                 <path fill="${color}" d="M400,840v-240h-40q-17,0 -28.5,-11.5T320,560v-200q0,-33 23.5,-56.5T400,280h160q33,0 56.5,23.5T640,360v200q0,17 -11.5,28.5T600,600h-40v240q0,17 -11.5,28.5T520,880h-80q-17,0 -28.5,-11.5T400,840Zm80,-600q-33,0 -56.5,-23.5T400,160q0,-33 23.5,-56.5T480,80q33,0 56.5,23.5T560,160q0,33 -23.5,56.5T480,240Z" />
               </svg>`,
        iconSize: [size, size],
        iconAnchor: [size / 2, size]
      });
    }

    function popupTable(props, keys, facId = null) {
      let incoming = facId ? (assignedPatientsByFacility[facId] || []) : [];
      let totalIncoming = incoming.length;
      let icuIncoming = incoming.filter(c => (c.nato_triage||"").toLowerCase().includes("red")).length;

      let html = '<div style="font:13px/1.25 system-ui,sans-serif; min-width: 220px;">';
      for (const k of keys) {
        const v = props ? props[k] : null;
        if (v === undefined || v === null) continue;

        if (k === "capacity" && typeof v === "object") {
          html += `<div style="margin-top: 8px; padding-top: 4px; border-top: 1px solid #eee;">`;
          html += `<span class="k" style="text-transform: uppercase; font-size: 11px; color: #666;">Capacity Status</span>`;
          html += `<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 4px; margin-top: 4px;">`;
          
          const bedAdd = totalIncoming > 0 ? ` <span style="color:#0078D7; font-weight:bold;" title="Newly assigned patients">+ ${totalIncoming}</span>` : "";
          const icuAdd = icuIncoming > 0 ? ` <span style="color:#0078D7; font-weight:bold;" title="Newly assigned ICU patients">+ ${icuIncoming}</span>` : "";

          html += `<div class="kv">Beds: <b>${v.beds_available}/${v.beds_total}</b>${bedAdd}</div>`;
          html += `<div class="kv">ICU: <b>${v.icu_available}/${v.icu_total}</b>${icuAdd}</div>`;
          html += `<div class="kv">Vents: <b>${v.vent_available}/${v.vent_total}</b>${icuAdd}</div>`;
          html += `</div></div>`;
        } else if (Array.isArray(v)) {
          if (!v.length) continue;
          html += `<div class="kv"><span class="k mono">${k}</span>: ${v.join(", ")}</div>`;
        } else {
          const s = String(v).trim();
          if (!s) continue;
          html += `<div class="kv"><span class="k mono">${k}</span>: ${s}</div>`;
        }
      }

      if (totalIncoming > 0) {
          html += `<div style="margin-top: 8px; padding-top: 4px; border-top: 1px solid #eee;">`;
          html += `<span class="k" style="text-transform: uppercase; font-size: 11px; color: #666;">Incoming Patients (${totalIncoming})</span>`;
          html += `<div style="max-height: 120px; overflow-y: auto; margin-top:4px; font-size: 11.5px; background: rgba(0,0,0,0.02); padding: 4px; border-radius: 4px;">`;
          incoming.forEach(p => {
              const tColor = triageColor(p.nato_triage);
              html += `<div onclick="showPatient(${p.case_id})" title="Click for patient details" style="margin-bottom:3px; padding-bottom: 3px; border-bottom: 1px solid rgba(0,0,0,0.05); cursor: pointer; transition: background 0.2s;" onmouseover="this.style.background='rgba(0,0,0,0.05)'" onmouseout="this.style.background='transparent'">
                         <b style="color:${tColor}; font-size: 14px; line-height: 10px;">&bull;</b> 
                         <span style="color: #0078D7; text-decoration: underline;"><b>Case ${p.case_id}</b></span> &mdash; ${p.nato_triage}
                       </div>`;
          });
          html += `</div></div>`;
      }

      html += '</div>';
      return html;
    }

    // Function to pan to and display a patient's full details
    window.showPatient = function(caseId) {
        // Find the patient in the currently loaded cases
        const patient = currentCases.find(c => c.properties.case_id === caseId);
        
        if (patient) {
            const coords = patient.geometry.coordinates;
            const latlng = [coords[1], coords[0]]; // Leaflet uses [lat, lon]
            
            // Specify the extended properties we want to show for the patient
            const keysToShow = [
                "case_id", "name", "age", "sex", "branch", 
                "nato_triage", "diagnosis", "evacuation_recommendation"
            ];
            
            // Pan the map to the patient
            map.panTo(latlng);
            
            // Open a new popup with the patient's full details
            L.popup({ autoPanPadding: [50, 50] })
              .setLatLng(latlng)
              .setContent(popupTable(patient.properties, keysToShow))
              .openOn(map);
        }
    };

    async function refreshHealthsitesStatus() {
      const el = document.getElementById("hsStatus");
      try {
        const r = await fetch("/api/healthsites/status");
        const j = await r.json();
        if (j.healthsites_available) {
          el.textContent = "healthsites: ON";
          el.className = "pill mono status-ok";
          attachHealthsitesLayers();
        } else {
          el.textContent = "healthsites: OFF";
          el.className = "pill mono status-warn";
        }
      } catch (e) {
        el.textContent = "healthsites: ?";
        el.className = "pill mono status-warn";
      }
    }

    function attachHealthsitesLayers() {
      if (healthsitesWays || healthsitesNodes) return;
      const gridOpts = { updateWhenIdle: false, keepBuffer: 10 };

      healthsitesWays = L.vectorGrid.protobuf('/tiles/ways/{z}/{x}/{y}.pbf', {
        ...gridOpts,
        vectorTileLayerStyles: {
          ways: function(props, zoom) { return { weight: zoom >= 12 ? 2 : 1, fill: true, fillOpacity: 0.12, opacity: 0.8 }; }
        },
        interactive: true,
        getFeatureId: f => (f.properties && (f.properties.upstream_id)) || null,
        maxNativeZoom: 14
      });

      healthsitesNodes = L.vectorGrid.protobuf('/tiles/nodes/{z}/{x}/{y}.pbf', {
        ...gridOpts,
        minZoom: 11,
        vectorTileLayerStyles: {
          nodes: function(props, zoom) {
            const r = zoom >= 14 ? 6 : (zoom >= 12 ? 4 : 3);
            return { radius: r, fill: true, fillOpacity: 0.65, weight: 1, opacity: 1 };
          }
        },
        interactive: true,
        getFeatureId: f => (f.properties && (f.properties.upstream_id)) || null,
        maxNativeZoom: 14
      });

      const popupOrder = ["name","health_facility:type","amenity","healthcare","bed_count","opening_hours","operator","contact:phone","website"];

      function showVTpopup(e) {
        const props = e.layer && e.layer.properties;
        L.popup().setLatLng(e.latlng).setContent(popupTable(props, popupOrder)).openOn(map);
      }
      healthsitesWays.on('click', showVTpopup);
      healthsitesNodes.on('click', showVTpopup);

      L.control.layers({}, {
        "Hospitals (Real-time Simulation)": demoFacilitiesLayer,
        "MASCAL Casualties": demoCasesLayer,
        "Evacuation Routes": demoRoutesLayer,
        "Healthsites (Base Layers)": healthsitesWays,
        "Healthsites (Points)": healthsitesNodes
      }, { collapsed: true }).addTo(map);
    }

    async function loadAllData() {
        const routeSummaryEl = document.getElementById("routeSummary");
        routeSummaryEl.textContent = "Loading data...";

        try {
            const caseRes = await fetch("/api/demo/cases");
            const caseFc = await caseRes.json();
            currentCases = caseFc.features || [];

            if (currentCases.length > 0) {
                const lons = currentCases.map(f => f.geometry.coordinates[0]);
                const lats = currentCases.map(f => f.geometry.coordinates[1]);
                casualtyBounds = {
                    minLon: Math.min(...lons), maxLon: Math.max(...lons),
                    minLat: Math.min(...lats), maxLat: Math.max(...lats)
                };
            }

            const facRes = await fetch(`/api/demo/facilities?buffer=${MAX_LOAD_RADIUS}`);
            const facFc = await facRes.json();
            allFacilitiesFeatures = facFc.features || [];

            renderCases();
            updateMapDisplay(); 
            routeSummaryEl.textContent = "Ready";
        } catch (err) {
            console.error("Load failed", err);
            routeSummaryEl.textContent = "Load Error";
        }
    }

    function updateMapDisplay() {
        const bufferVal = parseFloat(document.getElementById("searchBuffer").value);
        const hideUnused = document.getElementById("hideUnused").checked; 
        const currentZoom = map.getZoom(); 
        document.getElementById("radiusDisplay").textContent = bufferVal.toFixed(1);
        
        demoFacilitiesLayer.clearLayers();
        if (!casualtyBounds) return;

        let count = 0;
        allFacilitiesFeatures.forEach(f => {
            const [lon, lat] = f.geometry.coordinates;
            const p = f.properties || {};
            const facId = String(p.facility_id);

            const inBounds = (lon >= casualtyBounds.minLon - bufferVal && lon <= casualtyBounds.maxLon + bufferVal &&
                              lat >= casualtyBounds.minLat - bufferVal && lat <= casualtyBounds.maxLat + bufferVal);
            
            const isUsed = assignedFacilityIds.has(facId);
            const shouldShow = inBounds && (!hideUnused || isUsed);

            if (shouldShow) {
                const cap = p.capacity || {};
                const c = facilityColor(cap.beds_available, cap.beds_total);
                const rad = facilityRadius(p.role_of_care, currentZoom);

                // VISUAL MARKER (unclickable to prevent blocking hit area)
                const mVisual = L.circleMarker([lat, lon], {
                    radius: rad, color: "#111", weight: 1, fillColor: c, fillOpacity: 0.9, interactive: false
                });

                // INVISIBLE HIT-AREA MARKER (expanded radius, using 1% opacity black to guarantee Canvas hit detection)
                // INVISIBLE HIT-AREA MARKER (expanded radius, fully transparent)
                const mHit = L.circleMarker([lat, lon], {
                    radius: Math.max(20, rad + 12), color: "transparent", weight: 0, fillColor: "transparent", fillOpacity: 0, interactive: true
                }).bindPopup(popupTable(p, ["facility_id","name","role_of_care","specialties","capacity"], facId));
                
                mVisual.addTo(demoFacilitiesLayer);
                mHit.addTo(demoFacilitiesLayer);
                count++;
            }
        });
        document.getElementById("facCount").textContent = count;
        enforceZOrder();
    }

    function renderCases() {
      demoCasesLayer.clearLayers();
      const currentZoom = map.getZoom();
      const showRed = document.getElementById("triRed").checked;
      const showYellow = document.getElementById("triYellow").checked;
      const showGreen = document.getElementById("triGreen").checked;

      let count = 0;
      currentCases.forEach(f => {
        const triage = (f.properties.nato_triage || "").toLowerCase();
        let isVisible = false;
        if (showRed && (triage.includes("red") || triage.includes("immediate"))) isVisible = true;
        if (showYellow && (triage.includes("yellow") || triage.includes("delayed"))) isVisible = true;
        if (showGreen && (triage.includes("green") || triage.includes("minimal"))) isVisible = true;

        if (isVisible) {
          const c = triageColor(f.properties.nato_triage);
          const dynamicSize = Math.max(12, 24 * Math.pow(1.2, currentZoom - 7));
          
          // --- MODIFIED CODE START ---
          const patientKeys = [
              "case_id", "name", "age", "sex", "branch", 
              "nato_triage", "diagnosis", "evacuation_recommendation"
          ];
          
          L.marker([f.geometry.coordinates[1], f.geometry.coordinates[0]], {
            icon: getManIcon(c, dynamicSize)
          }).bindPopup(popupTable(f.properties, patientKeys))
            .addTo(demoCasesLayer);
          // --- MODIFIED CODE END ---
          
          count++;
        }
      });
      document.getElementById("caseCount").textContent = count;
      enforceZOrder();
    }

    function renderRoutes() {
      demoRoutesLayer.clearLayers();
      if (!document.getElementById("showRoutes").checked) {
          enforceZOrder();
          return;
      }

      const currentZoom = map.getZoom();
      const dynamicWeight = Math.max(0.5, 2 * Math.pow(1.1, currentZoom - 7));

      const showRed = document.getElementById("triRed").checked;
      const showYellow = document.getElementById("triYellow").checked;
      const showGreen = document.getElementById("triGreen").checked;

      currentRoutes.forEach(a => {
        const triage = (a.nato_triage || "").toLowerCase();
        let isVisible = false;
        if (showRed && (triage.includes("red") || triage.includes("immediate"))) isVisible = true;
        if (showYellow && (triage.includes("yellow") || triage.includes("delayed"))) isVisible = true;
        if (showGreen && (triage.includes("green") || triage.includes("minimal"))) isVisible = true;

        if (isVisible) {
          const col = triageColor(a.nato_triage);
          
          // Construct the popup content for the route
          const routePopupHTML = `
            <div style="font:13px/1.25 system-ui,sans-serif; min-width: 220px;">
              <div style="margin-bottom: 6px; padding-bottom: 4px; border-bottom: 1px solid #eee;">
                <b style="font-size: 14px;">Evacuation Route</b>
              </div>
              <div class="kv"><span class="k mono">Patient:</span> Case ${a.case_id}</div>
              <div class="kv"><span class="k mono">Triage:</span> <span style="color:${col}; font-weight:bold;">${a.nato_triage}</span></div>
              <div class="kv"><span class="k mono">Destination:</span> ${a.facility_name}</div>
              <div class="kv"><span class="k mono">Distance:</span> ${a.distance_km.toFixed(1)} km</div>
              <div class="kv"><span class="k mono">Reasoning:</span> ${a.reason}</div>
            </div>
          `;

          const routeCoords = [[a.case_coord[1], a.case_coord[0]], [a.facility_coord[1], a.facility_coord[0]]];

          // 1. VISUAL ROUTE (thin, visible, unclickable)
          L.polyline(routeCoords, { 
            weight: dynamicWeight, opacity: 0.8, color: col, interactive: false
          }).addTo(demoRoutesLayer);

          // 2. INVISIBLE HIT-AREA ROUTE (thick, nearly transparent, clickable)
          L.polyline(routeCoords, { 
            weight: 20, opacity: 0.01, color: "#000", interactive: true 
          })
          .bindPopup(routePopupHTML)
          .addTo(demoRoutesLayer);
        }
      });
      enforceZOrder();
    }

    async function runRouting() {
      const btn = document.getElementById("btnRoute");
      btn.disabled = true;
      try {
        const buffer = document.getElementById("searchBuffer").value;
        const body = {
          triage_filters: ["Immediate (Red)", "Delayed (Yellow)", "Minimal (Green)"],
          max_distance_km: Number(document.getElementById("maxKm").value || 350),
          allow_outside_area: true,
          max_routes_draw: 500,
          buffer: parseFloat(buffer)
        };
        const r = await fetch("/api/demo/route", {
          method: "POST", headers: { "Content-Type": "application/json" },
          body: JSON.stringify(body)
        });
        const j = await r.json();
        
        document.getElementById("routeSummary").textContent = `${j.results.assigned}/${j.results.cases_considered} assigned`;
        currentRoutes = j.routes_for_map || [];

        assignedFacilityIds.clear();
        assignedPatientsByFacility = {};

        // Track the assigned patients to their assigned facility
        currentRoutes.forEach(route => {
            if (route.facility_id) {
                const facId = String(route.facility_id);
                assignedFacilityIds.add(facId);
                
                if (!assignedPatientsByFacility[facId]) {
                    assignedPatientsByFacility[facId] = [];
                }
                assignedPatientsByFacility[facId].push(route);
            }
        });

        renderRoutes();

        const facRes = await fetch(`/api/demo/facilities?buffer=${MAX_LOAD_RADIUS}`);
        const facFc = await facRes.json();
        allFacilitiesFeatures = facFc.features || [];
        
        updateMapDisplay();

      } catch (e) { console.error(e); } finally { btn.disabled = false; }
    }

    async function resetDemo() {
      assignedFacilityIds.clear(); 
      assignedPatientsByFacility = {};
      document.getElementById("hideUnused").checked = false; 
      await fetch("/api/demo/reset", { 
        method: "POST", headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ buffer: MAX_LOAD_RADIUS })
      });
      await loadAllData();
      currentRoutes = [];
      demoRoutesLayer.clearLayers();
    }

    // Event Listeners
    document.getElementById("searchBuffer").addEventListener("input", updateMapDisplay);
    document.getElementById("hideUnused").addEventListener("change", updateMapDisplay); 
    document.getElementById("btnReset").addEventListener("click", resetDemo);
    document.getElementById("btnRoute").addEventListener("click", runRouting);
    document.getElementById("showRoutes").addEventListener("change", renderRoutes);
    
    // 1. Direct checkbox clicks (Toggle specific color only)
    document.getElementById("triRed").addEventListener("change", () => { renderCases(); renderRoutes(); });
    document.getElementById("triYellow").addEventListener("change", () => { renderCases(); renderRoutes(); });
    document.getElementById("triGreen").addEventListener("change", () => { renderCases(); renderRoutes(); });

    // 2. Text/Label clicks (Isolate the clicked color)
    document.getElementById("lblRed").addEventListener("click", () => {
      document.getElementById("triRed").checked = true;
      document.getElementById("triYellow").checked = false;
      document.getElementById("triGreen").checked = false;
      renderCases(); 
      renderRoutes();
    });

    document.getElementById("lblYellow").addEventListener("click", () => {
      document.getElementById("triRed").checked = false;
      document.getElementById("triYellow").checked = true;
      document.getElementById("triGreen").checked = false;
      renderCases(); 
      renderRoutes();
    });

    document.getElementById("lblGreen").addEventListener("click", () => {
      document.getElementById("triRed").checked = false;
      document.getElementById("triYellow").checked = false;
      document.getElementById("triGreen").checked = true;
      renderCases(); 
      renderRoutes();
    });

    map.on('zoomend', () => {
      updateMapDisplay();
      renderCases();
      renderRoutes(); 
    });

    // Initial Load
    loadAllData();
    refreshHealthsitesStatus().then(() => attachHealthsitesLayers());

  </script>
</body>
</html>