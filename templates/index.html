<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>NATO Med Interop Demo — Real-time Facility Routing</title>

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet.vectorgrid@1.3.0/dist/Leaflet.VectorGrid.bundled.js"></script>
  <script src="https://unpkg.com/leaflet-polylinedecorator/dist/leaflet.polylineDecorator.js"></script>

  <style>
    html, body { height: 100%; margin: 0; }
    #map { height: 100%; width: 100%; }

    /* Sidebar */
    .sidebar {
      position: absolute;
      top: 10px; left: 10px;
      z-index: 1000;
      width: 360px;
      max-width: calc(100vw - 20px);
      background: rgba(255,255,255,0.97);
      border-radius: 12px;
      box-shadow: 0 10px 26px rgba(0,0,0,0.18);
      font: 14px/1.25 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      overflow: hidden;
    }
    .sidebar header{
      padding: 10px 12px;
      border-bottom: 1px solid rgba(0,0,0,0.08);
      display:flex;
      gap:10px;
      align-items:baseline;
      justify-content:space-between;
    }
    .sidebar header b { font-size: 15px; }
    .sidebar header small { opacity: 0.75; }
    .sidebar .content { padding: 10px 12px; }
    .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .row + .row { margin-top: 10px; }
    button {
      appearance: none;
      border: 1px solid rgba(0,0,0,0.15);
      background: #fff;
      border-radius: 10px;
      padding: 8px 10px;
      cursor: pointer;
      box-shadow: 0 3px 10px rgba(0,0,0,0.08);
      font-weight: 650;
    }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    .pill {
      border: 1px solid rgba(0,0,0,0.14);
      border-radius: 999px;
      padding: 4px 8px;
      background: rgba(0,0,0,0.03);
      font-size: 12px;
    }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    .hr { height:1px; background: rgba(0,0,0,0.08); margin: 10px 0; }

    .kv { margin: 2px 0; }
    .k { font-weight: 700; }
    input[type="number"]{ width: 90px; padding: 6px 8px; border-radius: 10px; border: 1px solid rgba(0,0,0,0.15); }
    label { cursor: pointer; }

    .status-ok { color: #0a7; font-weight: 700;}
    .status-warn { color: #b60; font-weight: 700;}

    /* Slider specific styling */
    .slider-row { width: 100%; display: flex; flex-direction: column; gap: 4px; }
    #searchBuffer { width: 100%; cursor: pointer; }

    /* Icon Styling */
    .custom-man-icon { background: none; border: none; }
  </style>
</head>

<body>
  <div class="sidebar">
    <header>
      <div>
        <b>Medical Resource Exchange — Demo</b><br/>
        <small>Goal: “right patient → right facility → right time”</small>
      </div>
      <div class="pill mono" id="hsStatus">healthsites: ?</div>
    </header>

    <div class="content">
      <div class="row">
        <button id="btnReset" title="Reset facility availability to baseline">Reset Environment</button>
      </div>

      <div class="row">
        <span class="pill"><input id="triRed" type="checkbox" checked /> <label id="lblRed" style="cursor:pointer; user-select:none;">Immediate (Red)</label></span>
        <span class="pill"><input id="triYellow" type="checkbox" checked /> <label id="lblYellow" style="cursor:pointer; user-select:none;">Delayed (Yellow)</label></span>
        <span class="pill"><input id="triGreen" type="checkbox" checked /> <label id="lblGreen" style="cursor:pointer; user-select:none;">Minimal (Green)</label></span>
      </div>

      <div class="row">
        <label class="pill">Max Travel Distance [km] <input id="maxKm" type="number" value="350" min="10" max="2000"></label>
      </div>
      
      <div class="row slider-row">
        <label class="pill">
          Search Radius: <b id="radiusDisplay">1.5</b>° 
          <input id="searchBuffer" type="range" step="0.1" value="1.5" min="0.5" max="10.0">
        </label>
      </div>

      <div class="row">
        <button id="btnRoute">Run MASCAL Routing</button>
        <button id="btnClearIsolation" style="display:none; color: #d33; border-color: #d33;">Clear Isolation</button>
        <span class="pill"><input id="showRoutes" type="checkbox" checked /> <label for="showRoutes">Show routes</label></span>
        <span class="pill"><input id="showHotspots" type="checkbox" checked /> <label for="showHotspots">Hotspots</label></span>
        <span class="pill"><input id="clusterMode" type="checkbox" /> <label for="clusterMode">Cluster Mode</label></span>
        <span class="pill"><input id="hideUnused" type="checkbox" /> <label for="hideUnused">Hide unused</label></span>
      </div>

      <div class="hr"></div>

      <div id="summary">
        <div class="kv"><span class="k">Hospitals in Radius:</span> <span id="facCount">–</span></div>
        <div class="kv"><span class="k">Casualties:</span> <span id="caseCount">–</span></div>
        <div class="kv"><span class="k">Routing Result:</span> <span id="routeSummary">Ready</span></div>
      </div>

      <div class="hr"></div>

      <div style="opacity:0.85; font-size:12px;">
        <div class="kv"><span class="k">Note:</span> Pre-loads up to 10° on startup. Adjust slider for real-time visualization.</div>
      </div>
    </div>
  </div>

  <div id="map"></div>

  <script>
    // --- TUNABLE VARIABLE ---
    const MAX_LOAD_RADIUS = 10.0; 

    const map = L.map('map', { 
      center: [56.9, 23.7], 
      zoom: 7, 
      preferCanvas: true, // Uses HTML5 Canvas for high performance
      zoomControl: false
    });

    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19, 
      attribution: '&copy; OpenStreetMap contributors',
      updateWhenIdle: false, // Loads tiles immediately while panning
      keepBuffer: 10         // Keeps more tiles loaded outside the visible view
    }).addTo(map);

    // Using FeatureGroup instead of LayerGroup gives us bringToFront() and bringToBack() for canvas ordering
    const demoHotspotsLayer = L.featureGroup().addTo(map);
    const demoRoutesLayer = L.featureGroup().addTo(map);
    const demoFacilitiesLayer = L.featureGroup().addTo(map);
    const demoCasesLayer = L.featureGroup().addTo(map);

    let healthsitesWays = null;
    let healthsitesNodes = null;
    
    // Client-side Data Cache
    let allFacilitiesFeatures = []; 
    let currentCases = [];
    let currentRoutes = [];
    let casualtyBounds = null; 
    let assignedFacilityIds = new Set(); 
    let assignedPatientsByFacility = {}; 
    let activeClusters = [];
    
    // Isolation State
    let isolatedClusterCaseIds = null;

    // --- OSRM Routing Queue for Road-snapping ---
    let osrmQueue = [];
    let osrmCache = {}; 
    let isFetchingOsrm = false;
    let osrmGeneration = 0;

    async function processOsrmQueue(generation) {
        if (isFetchingOsrm) return;
        isFetchingOsrm = true;

        const summaryEl = document.getElementById("routeSummary");
        let baseSummary = summaryEl.innerHTML.split('<br>')[0];

        let totalTasks = osrmQueue.length;
        let processed = 0;

        while (osrmQueue.length > 0) {
            if (generation !== osrmGeneration) break;

            const task = osrmQueue.shift();
            processed++;

            if (!demoRoutesLayer.hasLayer(task.visualLine)) continue;

            try {
                const startKey = `${task.start[0].toFixed(3)},${task.start[1].toFixed(3)}`;
                const endKey = `${task.end[0].toFixed(3)},${task.end[1].toFixed(3)}`;
                const cacheKey = `${startKey}|${endKey}`;

                if (osrmCache[cacheKey] === "FETCHING") {
                    osrmQueue.push(task); 
                    await new Promise(r => setTimeout(r, 100));
                    continue;
                }

                if (osrmCache[cacheKey]) {
                    if (osrmCache[cacheKey] !== "NOROUTE" && osrmCache[cacheKey] !== "FETCHING") {
                        task.visualLine.setLatLngs(osrmCache[cacheKey]);
                        if (task.hitLine) task.hitLine.setLatLngs(osrmCache[cacheKey]);
                    }
                    continue;
                }

                osrmCache[cacheKey] = "FETCHING";

                if (processed % 2 === 0 || processed === 1) {
                    const pct = Math.round((processed / totalTasks) * 100);
                    summaryEl.innerHTML = `${baseSummary}<br><small style="color:#b60;">Snapping to roads... ${pct}%</small>`;
                }

                const url = `https://router.project-osrm.org/route/v1/driving/${task.start[0]},${task.start[1]};${task.end[0]},${task.end[1]}?overview=simplified&geometries=geojson`;
                const res = await fetch(url);
                
                if (res.status === 429) {
                    osrmCache[cacheKey] = null; 
                    osrmQueue.unshift(task); 
                    processed--; 
                    console.warn("OSRM API rate limit hit. Waiting 2.5s...");
                    await new Promise(r => setTimeout(r, 2500));
                    continue;
                }

                if (!res.ok) {
                    console.warn(`OSRM failed (HTTP ${res.status}). Coordinates: ${cacheKey}`);
                    osrmCache[cacheKey] = "NOROUTE";
                    continue;
                }

                const data = await res.json();
                let roadCoords = "NOROUTE";
                
                if (data.code === "Ok" && data.routes && data.routes.length > 0) {
                    roadCoords = data.routes[0].geometry.coordinates.map(c => [c[1], c[0]]);
                }
                
                osrmCache[cacheKey] = roadCoords;
                
                fetch("/api/demo/osrm_cache", {
                    method: "POST",
                    headers: {"Content-Type": "application/json"},
                    body: JSON.stringify({ [cacheKey]: roadCoords })
                }).catch(e => console.warn("Cache save failed", e));
                
                if (roadCoords !== "NOROUTE") {
                    task.visualLine.setLatLngs(roadCoords);
                    if (task.hitLine) task.hitLine.setLatLngs(roadCoords);
                }

                await new Promise(r => setTimeout(r, 150));

            } catch (e) {
                console.error("OSRM Routing iteration failed:", e);
            }
        }
        
        isFetchingOsrm = false;
        
        if (generation === osrmGeneration) {
            summaryEl.innerHTML = `${baseSummary}<br><small style="color:#0a7; font-weight:bold;">Road snapping complete</small>`;
        }
    }

    function enforceZOrder() {
        if (map.hasLayer(demoHotspotsLayer)) demoHotspotsLayer.bringToBack();
        if (map.hasLayer(demoRoutesLayer)) demoRoutesLayer.bringToBack();
        if (map.hasLayer(demoFacilitiesLayer)) demoFacilitiesLayer.bringToFront();
        if (map.hasLayer(demoCasesLayer)) demoCasesLayer.bringToFront(); 
    }

    function triageColor(triage) {
      const t = (triage || "").toLowerCase();
      if (t.includes("red") || t.includes("immediate")) return "#d33";
      if (t.includes("yellow") || t.includes("delayed")) return "#d9a300";
      return "#2a7";
    }

    function facilityColor(bedsAvailable, bedsTotal) {
      const tot = Math.max(1, Number(bedsTotal || 1));
      const av = Math.max(0, Number(bedsAvailable || 0));
      const ratio = av / tot;
      if (ratio <= 0.05) return "#b11";
      if (ratio <= 0.15) return "#b60";
      if (ratio <= 0.30) return "#c9b200";
      return "#0a7";
    }

    function facilityRadius(role, zoom) {
      const r = (role || "").toLowerCase();
      let baseSize = 2; 
      if (r.includes("role4")) baseSize = 5; 
      else if (r.includes("role3")) baseSize = 3; 
      else if (r.includes("role2")) baseSize = 2; 

      return Math.max(0.5, baseSize * Math.pow(1.15, zoom - 7));
    }

    function getManIcon(color, size) {
      return L.divIcon({
        className: 'custom-man-icon',
        html: `<svg viewBox="0 0 960 960" width="${size}" height="${size}">
                 <path fill="${color}" d="M400,840v-240h-40q-17,0 -28.5,-11.5T320,560v-200q0,-33 23.5,-56.5T400,280h160q33,0 56.5,23.5T640,360v200q0,17 -11.5,28.5T600,600h-40v240q0,17 -11.5,28.5T520,880h-80q-17,0 -28.5,-11.5T400,840Zm80,-600q-33,0 -56.5,-23.5T400,160q0,-33 23.5,-56.5T480,80q33,0 56.5,23.5T560,160q0,33 -23.5,56.5T480,240Z" />
               </svg>`,
        iconSize: [size, size],
        iconAnchor: [size / 2, size]
      });
    }

    function popupTable(props, keys, facId = null) {
      let incoming = facId ? (assignedPatientsByFacility[facId] || []) : [];
      let totalIncoming = incoming.length;
      let icuIncoming = incoming.filter(c => (c.nato_triage||"").toLowerCase().includes("red")).length;

      let html = '<div style="font:13px/1.25 system-ui,sans-serif; min-width: 220px;">';
      for (const k of keys) {
        const v = props ? props[k] : null;
        if (v === undefined || v === null) continue;

        if (k === "capacity" && typeof v === "object") {
          html += `<div style="margin-top: 8px; padding-top: 4px; border-top: 1px solid #eee;">`;
          html += `<span class="k" style="text-transform: uppercase; font-size: 11px; color: #666;">Capacity Status</span>`;
          html += `<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 4px; margin-top: 4px;">`;
          
          const bedAdd = totalIncoming > 0 ? ` <span style="color:#0078D7; font-weight:bold;" title="Newly assigned patients">+ ${totalIncoming}</span>` : "";
          const icuAdd = icuIncoming > 0 ? ` <span style="color:#0078D7; font-weight:bold;" title="Newly assigned ICU patients">+ ${icuIncoming}</span>` : "";

          html += `<div class="kv">Beds: <b>${v.beds_available}/${v.beds_total}</b>${bedAdd}</div>`;
          html += `<div class="kv">ICU: <b>${v.icu_available}/${v.icu_total}</b>${icuAdd}</div>`;
          html += `<div class="kv">Vents: <b>${v.vent_available}/${v.vent_total}</b>${icuAdd}</div>`;
          html += `</div></div>`;
        } else if (Array.isArray(v)) {
          if (!v.length) continue;
          html += `<div class="kv"><span class="k mono">${k}</span>: ${v.join(", ")}</div>`;
        } else {
          const s = String(v).trim();
          if (!s) continue;
          html += `<div class="kv"><span class="k mono">${k}</span>: ${s}</div>`;
        }
      }

      if (totalIncoming > 0) {
          html += `<div style="margin-top: 8px; padding-top: 4px; border-top: 1px solid #eee;">`;
          html += `<span class="k" style="text-transform: uppercase; font-size: 11px; color: #666;">Incoming Patients (${totalIncoming})</span>`;
          html += `<div style="max-height: 120px; overflow-y: auto; margin-top:4px; font-size: 11.5px; background: rgba(0,0,0,0.02); padding: 4px; border-radius: 4px;">`;
          incoming.forEach(p => {
              const tColor = triageColor(p.nato_triage);
              html += `<div onclick="showPatient(${p.case_id})" title="Click for patient details" style="margin-bottom:3px; padding-bottom: 3px; border-bottom: 1px solid rgba(0,0,0,0.05); cursor: pointer; transition: background 0.2s;" onmouseover="this.style.background='rgba(0,0,0,0.05)'" onmouseout="this.style.background='transparent'">
                         <b style="color:${tColor}; font-size: 14px; line-height: 10px;">&bull;</b> 
                         <span style="color: #0078D7; text-decoration: underline;"><b>Case ${p.case_id}</b></span> &mdash; ${p.nato_triage}
                       </div>`;
          });
          html += `</div></div>`;
      }

      html += '</div>';
      return html;
    }

    window.showPatient = function(caseId) {
        const patient = currentCases.find(c => c.properties.case_id === caseId);
        
        if (patient) {
            const coords = patient.geometry.coordinates;
            const latlng = [coords[1], coords[0]]; 
            
            const keysToShow = [
                "case_id", "name", "age", "sex", "branch", 
                "nato_triage", "diagnosis", "evacuation_recommendation"
            ];
            
            map.panTo(latlng);
            
            L.popup({ autoPanPadding: [50, 50] })
              .setLatLng(latlng)
              .setContent(popupTable(patient.properties, keysToShow))
              .openOn(map);
        }
    };

    function getEdgeCoord(centerLat, centerLon, destLat, destLon, radiusMeters) {
        const R = 6378137; 
        const dLat = (destLat - centerLat) * Math.PI / 180;
        const dLon = (destLon - centerLon) * Math.PI / 180;
        const lat1 = centerLat * Math.PI / 180;
        const lat2 = destLat * Math.PI / 180;

        const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                Math.sin(dLon/2) * Math.sin(dLon/2) * Math.cos(lat1) * Math.cos(lat2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        const distance = R * c;

        if (distance === 0 || distance <= radiusMeters) return [centerLat, centerLon];

        const ratio = radiusMeters / distance;
        return [
            centerLat + (destLat - centerLat) * ratio,
            centerLon + (destLon - centerLon) * ratio
        ];
    }

    function buildClusters() {
        activeClusters = [];
        const showRed = document.getElementById("triRed").checked;
        const showYellow = document.getElementById("triYellow").checked;
        const showGreen = document.getElementById("triGreen").checked;
        const CLUSTER_THRESHOLD_METERS = 2000;

        currentCases.forEach(f => {
            const triage = (f.properties.nato_triage || "").toLowerCase();
            let isRed = false, isYellow = false, isGreen = false;
            
            if (triage.includes("red") || triage.includes("immediate")) isRed = true;
            else if (triage.includes("yellow") || triage.includes("delayed")) isYellow = true;
            else if (triage.includes("green") || triage.includes("minimal")) isGreen = true;

            const lat = f.geometry.coordinates[1];
            const lon = f.geometry.coordinates[0];
            let foundCluster = null;
            let minD = Infinity;

            for (const c of activeClusters) {
                const d = map.distance([lat, lon], [c.lat, c.lon]);
                if (d < CLUSTER_THRESHOLD_METERS && d < minD) {
                    minD = d;
                    foundCluster = c;
                }
            }

            if (foundCluster) {
                foundCluster.lat = ((foundCluster.lat * foundCluster.totalCount) + lat) / (foundCluster.totalCount + 1);
                foundCluster.lon = ((foundCluster.lon * foundCluster.totalCount) + lon) / (foundCluster.totalCount + 1);
                foundCluster.totalCount++;
                foundCluster.cases.push(f.properties.case_id);
                
                if (isRed) foundCluster.redCount++;
                if (isYellow) foundCluster.yellowCount++;
                if (isGreen) foundCluster.greenCount++;
            } else {
                activeClusters.push({ 
                    lat: lat, lon: lon, totalCount: 1, cases: [f.properties.case_id],
                    redCount: isRed ? 1 : 0,
                    yellowCount: isYellow ? 1 : 0,
                    greenCount: isGreen ? 1 : 0
                });
            }
        });

        activeClusters = activeClusters.filter(c => {
            c.visibleCount = 0;
            c.severity = 1;
            
            if (showRed && c.redCount > 0) { 
                c.visibleCount += c.redCount; 
                c.severity = 3; 
            }
            if (showYellow && c.yellowCount > 0) { 
                c.visibleCount += c.yellowCount; 
                if (c.severity < 3) c.severity = 2; 
            }
            if (showGreen && c.greenCount > 0) { 
                c.visibleCount += c.greenCount; 
            }
            
            return c.totalCount > 4 && c.visibleCount > 0;
        });

        activeClusters.forEach(c => {
            c.count = c.visibleCount; 
            c.radiusMeters = 2000 + (c.visibleCount * 800); 
            
            if (c.severity === 3) c.color = "#d33";
            else if (c.severity === 2) c.color = "#d9a300";
            else c.color = "#2a7";
        });
    }

    async function refreshHealthsitesStatus() {
      const el = document.getElementById("hsStatus");
      try {
        const r = await fetch("/api/healthsites/status");
        const j = await r.json();
        if (j.healthsites_available) {
          el.textContent = "healthsites: ON";
          el.className = "pill mono status-ok";
          attachHealthsitesLayers();
        } else {
          el.textContent = "healthsites: OFF";
          el.className = "pill mono status-warn";
        }
      } catch (e) {
        el.textContent = "healthsites: ?";
        el.className = "pill mono status-warn";
      }
    }

    function attachHealthsitesLayers() {
      if (healthsitesWays || healthsitesNodes) return;
      const gridOpts = { updateWhenIdle: false, keepBuffer: 10 };

      healthsitesWays = L.vectorGrid.protobuf('/tiles/ways/{z}/{x}/{y}.pbf', {
        ...gridOpts,
        vectorTileLayerStyles: {
          ways: function(props, zoom) { return { weight: zoom >= 12 ? 2 : 1, fill: true, fillOpacity: 0.12, opacity: 0.8 }; }
        },
        interactive: true,
        getFeatureId: f => (f.properties && (f.properties.upstream_id)) || null,
        maxNativeZoom: 14
      });

      healthsitesNodes = L.vectorGrid.protobuf('/tiles/nodes/{z}/{x}/{y}.pbf', {
        ...gridOpts,
        minZoom: 11,
        vectorTileLayerStyles: {
          nodes: function(props, zoom) {
            const r = zoom >= 14 ? 6 : (zoom >= 12 ? 4 : 3);
            return { radius: r, fill: true, fillOpacity: 0.65, weight: 1, opacity: 1 };
          }
        },
        interactive: true,
        getFeatureId: f => (f.properties && (f.properties.upstream_id)) || null,
        maxNativeZoom: 14
      });

      const popupOrder = ["name","health_facility:type","amenity","healthcare","bed_count","opening_hours","operator","contact:phone","website"];

      function showVTpopup(e) {
        const props = e.layer && e.layer.properties;
        L.popup().setLatLng(e.latlng).setContent(popupTable(props, popupOrder)).openOn(map);
      }
      healthsitesWays.on('click', showVTpopup);
      healthsitesNodes.on('click', showVTpopup);

      L.control.layers({}, {
        "Hospitals (Real-time Simulation)": demoFacilitiesLayer,
        "MASCAL Casualties": demoCasesLayer,
        "Crisis Hotspots": demoHotspotsLayer,
        "Evacuation Routes": demoRoutesLayer,
        "Healthsites (Base Layers)": healthsitesWays,
        "Healthsites (Points)": healthsitesNodes
      }, { collapsed: true }).addTo(map);
    }

    async function loadAllData() {
        const routeSummaryEl = document.getElementById("routeSummary");
        routeSummaryEl.textContent = "Loading data...";

        try {
            try {
                const cacheRes = await fetch("/api/demo/osrm_cache");
                if (cacheRes.ok) {
                    const serverCache = await cacheRes.json();
                    osrmCache = { ...serverCache, ...osrmCache };
                }
            } catch(e) { console.warn("Failed to load OSRM cache from server", e); }

            const caseRes = await fetch("/api/demo/cases");
            const caseFc = await caseRes.json();
            currentCases = caseFc.features || [];

            if (currentCases.length > 0) {
                const lons = currentCases.map(f => f.geometry.coordinates[0]);
                const lats = currentCases.map(f => f.geometry.coordinates[1]);
                casualtyBounds = {
                    minLon: Math.min(...lons), maxLon: Math.max(...lons),
                    minLat: Math.min(...lats), maxLat: Math.max(...lats)
                };
            }

            const facRes = await fetch(`/api/demo/facilities?buffer=${MAX_LOAD_RADIUS}`);
            const facFc = await facRes.json();
            allFacilitiesFeatures = facFc.features || [];

            buildClusters();
            
            renderCases();
            renderHotspots();
            updateMapDisplay(); 
            routeSummaryEl.textContent = "Ready";
        } catch (err) {
            console.error("Load failed", err);
            routeSummaryEl.textContent = "Load Error";
        }
    }

    function updateMapDisplay() {
        const bufferVal = parseFloat(document.getElementById("searchBuffer").value);
        const hideUnused = document.getElementById("hideUnused").checked; 
        const currentZoom = map.getZoom(); 
        document.getElementById("radiusDisplay").textContent = bufferVal.toFixed(1);
        
        let activeIsolatedFacilities = new Set();
        if (isolatedClusterCaseIds) {
            currentRoutes.forEach(r => {
                if (isolatedClusterCaseIds.has(r.case_id) && r.facility_id) {
                    activeIsolatedFacilities.add(String(r.facility_id));
                }
            });
        }
        
        demoFacilitiesLayer.clearLayers();
        if (!casualtyBounds) return;

        let count = 0;
        allFacilitiesFeatures.forEach(f => {
            const [lon, lat] = f.geometry.coordinates;
            const p = f.properties || {};
            const facId = String(p.facility_id);

            const inBounds = (lon >= casualtyBounds.minLon - bufferVal && lon <= casualtyBounds.maxLon + bufferVal &&
                              lat >= casualtyBounds.minLat - bufferVal && lat <= casualtyBounds.maxLat + bufferVal);
            
            const isUsed = assignedFacilityIds.has(facId);
            let shouldShow = inBounds && (!hideUnused || isUsed);

            if (isolatedClusterCaseIds) {
                shouldShow = activeIsolatedFacilities.has(facId);
            }

            if (shouldShow) {
                const cap = p.capacity || {};
                const c = facilityColor(cap.beds_available, cap.beds_total);
                const rad = facilityRadius(p.role_of_care, currentZoom);

                const mVisual = L.circleMarker([lat, lon], {
                    radius: rad, color: "#111", weight: 1, fillColor: c, fillOpacity: 0.9, interactive: false
                });

                const mHit = L.circleMarker([lat, lon], {
                    radius: Math.max(20, rad + 12), color: "transparent", weight: 0, fillColor: "transparent", fillOpacity: 0, interactive: true
                }).bindPopup(popupTable(p, ["facility_id","name","role_of_care","specialties","capacity"], facId));
                
                mVisual.addTo(demoFacilitiesLayer);
                mHit.addTo(demoFacilitiesLayer);
                count++;
            }
        });
        document.getElementById("facCount").textContent = count;
        enforceZOrder();
    }

    function renderCases() {
      demoCasesLayer.clearLayers();
      
      if (document.getElementById("clusterMode").checked) {
          enforceZOrder();
          return; 
      }

      const currentZoom = map.getZoom();
      const showRed = document.getElementById("triRed").checked;
      const showYellow = document.getElementById("triYellow").checked;
      const showGreen = document.getElementById("triGreen").checked;

      let count = 0;
      currentCases.forEach(f => {
        if (isolatedClusterCaseIds && !isolatedClusterCaseIds.has(f.properties.case_id)) return;

        const triage = (f.properties.nato_triage || "").toLowerCase();
        let isVisible = false;
        if (showRed && (triage.includes("red") || triage.includes("immediate"))) isVisible = true;
        if (showYellow && (triage.includes("yellow") || triage.includes("delayed"))) isVisible = true;
        if (showGreen && (triage.includes("green") || triage.includes("minimal"))) isVisible = true;

        if (isVisible) {
          const c = triageColor(f.properties.nato_triage);
          const dynamicSize = Math.max(12, 24 * Math.pow(1.2, currentZoom - 7));
          
          const patientKeys = [
              "case_id", "name", "age", "sex", "branch", 
              "nato_triage", "diagnosis", "evacuation_recommendation"
          ];
          
          L.marker([f.geometry.coordinates[1], f.geometry.coordinates[0]], {
            icon: getManIcon(c, dynamicSize)
          }).bindPopup(popupTable(f.properties, patientKeys))
            .addTo(demoCasesLayer);
          
          count++;
        }
      });
      document.getElementById("caseCount").textContent = count;
      enforceZOrder();
    }

    function getCircleCoords(lat, lon, radiusMeters, points = 64) {
        const coords = [];
        const R = 6378137; 
        const d = radiusMeters / R;
        const lat1 = lat * Math.PI / 180;
        const lon1 = lon * Math.PI / 180;

        for (let i = 0; i <= points; i++) {
            const brng = (i / points) * 2 * Math.PI;
            const lat2 = Math.asin(Math.sin(lat1) * Math.cos(d) + Math.cos(lat1) * Math.sin(d) * Math.cos(brng));
            const lon2 = lon1 + Math.atan2(Math.sin(brng) * Math.sin(d) * Math.cos(lat1), Math.cos(d) - Math.sin(lat1) * Math.sin(lat2));
            coords.push([lat2 * 180 / Math.PI, lon2 * 180 / Math.PI]);
        }
        return coords;
    }

    function renderHotspots() {
      demoHotspotsLayer.clearLayers();
      if (!document.getElementById("showHotspots").checked && !document.getElementById("clusterMode").checked) {
          enforceZOrder();
          return;
      }

      const showRed = document.getElementById("triRed").checked;
      const showYellow = document.getElementById("triYellow").checked;
      const showGreen = document.getElementById("triGreen").checked;

      activeClusters.forEach((c, index) => {
        if (isolatedClusterCaseIds) {
            const hasIsolated = c.cases.some(id => isolatedClusterCaseIds.has(id));
            if (!hasIsolated) return;
        }

        const popupHTML = `
          <div style="font:13px/1.25 system-ui,sans-serif; text-align: center; min-width: 170px;">
            <div style="margin-bottom: 6px; padding-bottom: 4px; border-bottom: 1px solid #eee;">
              <b style="color: #111; font-size: 14px; text-transform: uppercase;">Crisis Cluster</b>
            </div>
            <div style="margin: 8px 0; font-size: 28px; font-weight: 800; color: #111; line-height: 1;">
              ${c.count}
            </div>
            <div style="color: #666; font-size: 11px; text-transform: uppercase; font-weight: 600; margin-bottom: 12px;">
              Filtered Casualties
            </div>
            
            <div style="text-align: left; font-size: 10px; color: #888; text-transform: uppercase; margin-bottom: 4px;">
              Total in Area:
            </div>
            <div style="display: flex; justify-content: space-between; font-weight: bold; font-size: 12px; border-top: 1px solid #eee; padding-top: 6px;">
              <span style="color: #d33;" title="Immediate (Red)">T1: ${c.redCount || 0}</span>
              <span style="color: #d9a300;" title="Delayed (Yellow)">T2: ${c.yellowCount || 0}</span>
              <span style="color: #2a7;" title="Minimal (Green)">T3: ${c.greenCount || 0}</span>
            </div>
            ${!isolatedClusterCaseIds ? `
            <div style="margin-top: 10px; text-align: center;">
                <button onclick="isolateClusterByIndex(${index})" style="width: 100%; background: #0078D7; color: white; border: none; padding: 6px; border-radius: 4px; font-weight: bold; cursor: pointer;">Isolate Cluster</button>
            </div>` : ''}
          </div>
        `;

        let activeCats = [];
        if (showRed && c.redCount > 0) activeCats.push({ color: "#d33", count: c.redCount });
        if (showYellow && c.yellowCount > 0) activeCats.push({ color: "#d9a300", count: c.yellowCount });
        if (showGreen && c.greenCount > 0) activeCats.push({ color: "#2a7", count: c.greenCount });

        activeCats.sort((a, b) => a.count - b.count);

        let currentCumulativeCount = 0;
        let previousCoords = null;

        activeCats.forEach((cat, index) => {
            currentCumulativeCount += cat.count;
            
            let currentRadius = 2000 + (currentCumulativeCount * 800);
            let currentCoords = getCircleCoords(c.lat, c.lon, currentRadius);

            let latlngs = index === 0 ? [currentCoords] : [currentCoords, [...previousCoords].reverse()];

            L.polygon(latlngs, {
                color: cat.color,
                fillColor: cat.color,
                fillOpacity: 0.35, 
                weight: 2,
                dashArray: '6, 6',
                interactive: true 
            })
            .bindPopup(popupHTML)
            .addTo(demoHotspotsLayer);

            previousCoords = currentCoords;
        });
      });

      enforceZOrder();
    }

    function renderRoutes() {
      demoRoutesLayer.clearLayers();
      
      osrmGeneration++;
      isFetchingOsrm = false; 
      osrmQueue = []; 

      if (!document.getElementById("showRoutes").checked) {
          enforceZOrder();
          return;
      }

      const currentZoom = map.getZoom();
      const dynamicWeight = Math.max(0.5, 2 * Math.pow(1.1, currentZoom - 7));
      const clusterMode = document.getElementById("clusterMode").checked;

      const showRed = document.getElementById("triRed").checked;
      const showYellow = document.getElementById("triYellow").checked;
      const showGreen = document.getElementById("triGreen").checked;

      if (clusterMode) {
          let clusterRoutes = {};
          
          currentRoutes.forEach(a => {
              if (isolatedClusterCaseIds && !isolatedClusterCaseIds.has(a.case_id)) return;

              const triage = (a.nato_triage || "").toLowerCase();
              let isVisible = false;
              if (showRed && (triage.includes("red") || triage.includes("immediate"))) isVisible = true;
              if (showYellow && (triage.includes("yellow") || triage.includes("delayed"))) isVisible = true;
              if (showGreen && (triage.includes("green") || triage.includes("minimal"))) isVisible = true;
              
              if (!isVisible) return;
              
              let myClusterIndex = activeClusters.findIndex(c => c.cases.includes(a.case_id));
              
              if (myClusterIndex !== -1) {
                  const key = myClusterIndex + "_" + a.facility_id;
                  if (!clusterRoutes[key]) {
                      clusterRoutes[key] = {
                          cluster: activeClusters[myClusterIndex],
                          facility_id: a.facility_id,
                          facility_name: a.facility_name,
                          facility_coord: a.facility_coord,
                          patients: [],
                          severity: 1
                      };
                  }
                  clusterRoutes[key].patients.push(a);
                  let sev = triage.includes("red") ? 3 : (triage.includes("yellow") ? 2 : 1);
                  clusterRoutes[key].severity = Math.max(clusterRoutes[key].severity, sev);
              }
          });
          
          Object.values(clusterRoutes).forEach(cr => {
              const col = cr.severity === 3 ? "#d33" : (cr.severity === 2 ? "#d9a300" : "#2a7");
              const edgeCoord = getEdgeCoord(
                  cr.cluster.lat, cr.cluster.lon, 
                  cr.facility_coord[1], cr.facility_coord[0], 
                  cr.cluster.radiusMeters
              );
              
              const routeCoords = [edgeCoord, [cr.facility_coord[1], cr.facility_coord[0]]];
              const routePopupHTML = `
                <div style="font:13px/1.25 system-ui,sans-serif; min-width: 250px;">
                  <div style="margin-bottom: 6px; padding-bottom: 4px; border-bottom: 1px solid #eee;">
                    <b style="font-size: 14px;">Cluster Evacuation Route</b>
                  </div>
                  <div class="kv"><span class="k mono">Destination:</span> ${cr.facility_name}</div>
                  <div class="kv" style="margin-top: 6px;"><span class="k mono">Patients (${cr.patients.length}):</span></div>
                  <div style="max-height: 150px; overflow-y: auto; margin-top:4px; font-size: 11.5px; background: rgba(0,0,0,0.02); padding: 4px; border-radius: 4px;">
                    ${cr.patients.map(p => {
                       const pCol = triageColor(p.nato_triage);
                       return `<div onclick="showPatient(${p.case_id})" title="Click for patient details" style="margin-bottom:3px; padding-bottom: 3px; border-bottom: 1px solid rgba(0,0,0,0.05); cursor: pointer; transition: background 0.2s;" onmouseover="this.style.background='rgba(0,0,0,0.05)'" onmouseout="this.style.background='transparent'">
                                 <b style="color:${pCol}; font-size: 14px; line-height: 10px;">&bull;</b> 
                                 <span style="color: #0078D7; text-decoration: underline;"><b>Case ${p.case_id}</b></span> &mdash; ${p.nato_triage}
                               </div>`;
                    }).join('')}
                  </div>
                </div>
              `;

              const visualLine = L.polyline(routeCoords, { weight: dynamicWeight * 2, opacity: 0.8, color: col, interactive: false }).addTo(demoRoutesLayer);
              const hitLine = L.polyline(routeCoords, { weight: 20, opacity: 0.01, color: "#000", interactive: true }).bindPopup(routePopupHTML).addTo(demoRoutesLayer);
              
              osrmQueue.push({
                  start: [cr.cluster.lon, cr.cluster.lat], 
                  end: cr.facility_coord,
                  visualLine: visualLine,
                  hitLine: hitLine
              });
          });
          
      } else {
          let aggregatedRoutes = {};
          
          currentRoutes.forEach(a => {
            if (isolatedClusterCaseIds && !isolatedClusterCaseIds.has(a.case_id)) return;

            const triage = (a.nato_triage || "").toLowerCase();
            let isVisible = false;
            if (showRed && (triage.includes("red") || triage.includes("immediate"))) isVisible = true;
            if (showYellow && (triage.includes("yellow") || triage.includes("delayed"))) isVisible = true;
            if (showGreen && (triage.includes("green") || triage.includes("minimal"))) isVisible = true;

            if (isVisible) {
              const startKey = `${a.case_coord[0].toFixed(2)},${a.case_coord[1].toFixed(2)}`;
              const endKey = `${a.facility_coord[0].toFixed(3)},${a.facility_coord[1].toFixed(3)}`;
              const key = `${startKey}|${endKey}`;

              if (!aggregatedRoutes[key]) {
                  aggregatedRoutes[key] = {
                      patients: [],
                      facility_name: a.facility_name,
                      facility_coord: a.facility_coord,
                      start_coord: a.case_coord,
                      severity: 1,
                      distance_km: a.distance_km,
                      reason: a.reason
                  };
              }
              aggregatedRoutes[key].patients.push(a);
              let sev = triage.includes("red") ? 3 : (triage.includes("yellow") ? 2 : 1);
              aggregatedRoutes[key].severity = Math.max(aggregatedRoutes[key].severity, sev);
            }
          });

          Object.values(aggregatedRoutes).forEach(g => {
              const col = g.severity === 3 ? "#d33" : (g.severity === 2 ? "#d9a300" : "#2a7");
              
              const routePopupHTML = `
                <div style="font:13px/1.25 system-ui,sans-serif; min-width: 250px;">
                  <div style="margin-bottom: 6px; padding-bottom: 4px; border-bottom: 1px solid #eee;">
                    <b style="font-size: 14px;">Evacuation Route</b>
                  </div>
                  <div class="kv"><span class="k mono">Destination:</span> ${g.facility_name}</div>
                  <div class="kv"><span class="k mono">Distance:</span> ${g.distance_km.toFixed(1)} km</div>
                  <div class="kv"><span class="k mono">Reasoning:</span> ${g.reason}</div>
                  <div class="kv" style="margin-top: 6px;"><span class="k mono">Patients (${g.patients.length}):</span></div>
                  <div style="max-height: 150px; overflow-y: auto; margin-top:4px; font-size: 11.5px; background: rgba(0,0,0,0.02); padding: 4px; border-radius: 4px;">
                    ${g.patients.map(p => {
                       const pCol = triageColor(p.nato_triage);
                       return `<div onclick="showPatient(${p.case_id})" title="Click for patient details" style="margin-bottom:3px; padding-bottom: 3px; border-bottom: 1px solid rgba(0,0,0,0.05); cursor: pointer; transition: background 0.2s;" onmouseover="this.style.background='rgba(0,0,0,0.05)'" onmouseout="this.style.background='transparent'">
                                 <b style="color:${pCol}; font-size: 14px; line-height: 10px;">&bull;</b> 
                                 <span style="color: #0078D7; text-decoration: underline;"><b>Case ${p.case_id}</b></span> &mdash; ${p.nato_triage}
                               </div>`;
                    }).join('')}
                  </div>
                </div>
              `;

              const baseWeight = Math.min(6, dynamicWeight * (1 + (g.patients.length - 1) * 0.15));

              const routeCoords = [[g.start_coord[1], g.start_coord[0]], [g.facility_coord[1], g.facility_coord[0]]];
              const visualLine = L.polyline(routeCoords, { weight: baseWeight, opacity: 0.8, color: col, interactive: false }).addTo(demoRoutesLayer);
              const hitLine = L.polyline(routeCoords, { weight: 20, opacity: 0.01, color: "#000", interactive: true }).bindPopup(routePopupHTML).addTo(demoRoutesLayer);
              
              osrmQueue.push({
                  start: g.start_coord,
                  end: g.facility_coord,
                  visualLine: visualLine,
                  hitLine: hitLine
              });
          });
      }
      
      enforceZOrder();
      processOsrmQueue(osrmGeneration); 
    }

    async function runRouting() {
      const btn = document.getElementById("btnRoute");
      btn.disabled = true;
      try {
        const buffer = document.getElementById("searchBuffer").value;
        const body = {
          triage_filters: ["Immediate (Red)", "Delayed (Yellow)", "Minimal (Green)"],
          max_distance_km: Number(document.getElementById("maxKm").value || 350),
          allow_outside_area: true,
          max_routes_draw: 500,
          buffer: parseFloat(buffer)
        };
        const r = await fetch("/api/demo/route", {
          method: "POST", headers: { "Content-Type": "application/json" },
          body: JSON.stringify(body)
        });
        const j = await r.json();
        
        document.getElementById("routeSummary").innerHTML = `${j.results.assigned}/${j.results.cases_considered} assigned`;
        currentRoutes = j.routes_for_map || [];

        assignedFacilityIds.clear();
        assignedPatientsByFacility = {};

        currentRoutes.forEach(route => {
            if (route.facility_id) {
                const facId = String(route.facility_id);
                assignedFacilityIds.add(facId);
                
                if (!assignedPatientsByFacility[facId]) {
                    assignedPatientsByFacility[facId] = [];
                }
                assignedPatientsByFacility[facId].push(route);
            }
        });

        renderRoutes();

        const facRes = await fetch(`/api/demo/facilities?buffer=${MAX_LOAD_RADIUS}`);
        const facFc = await facRes.json();
        allFacilitiesFeatures = facFc.features || [];
        
        updateMapDisplay();

      } catch (e) { console.error(e); } finally { btn.disabled = false; }
    }

    async function resetDemo() {
      assignedFacilityIds.clear(); 
      assignedPatientsByFacility = {};
      isolatedClusterCaseIds = null;
      document.getElementById("btnClearIsolation").style.display = "none";
      document.getElementById("hideUnused").checked = false; 
      await fetch("/api/demo/reset", { 
        method: "POST", headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ buffer: MAX_LOAD_RADIUS })
      });
      await loadAllData();
      currentRoutes = [];
      demoRoutesLayer.clearLayers();
    }

    window.isolateClusterByIndex = function(idx) {
        const c = activeClusters[idx];
        if (!c) return;
        isolatedClusterCaseIds = new Set(c.cases);
        document.getElementById("btnClearIsolation").style.display = "inline-block";
        map.closePopup();
        
        let lats = [], lons = [];
        currentCases.forEach(f => {
            if (isolatedClusterCaseIds.has(f.properties.case_id)) {
                lons.push(f.geometry.coordinates[0]);
                lats.push(f.geometry.coordinates[1]);
            }
        });
        currentRoutes.forEach(r => {
            if (isolatedClusterCaseIds.has(r.case_id) && r.facility_coord) {
                lons.push(r.facility_coord[0]);
                lats.push(r.facility_coord[1]);
            }
        });

        if (lats.length > 0 && lons.length > 0) {
            const minLat = Math.min(...lats), maxLat = Math.max(...lats);
            const minLon = Math.min(...lons), maxLon = Math.max(...lons);
            map.flyToBounds([[minLat, minLon], [maxLat, maxLon]], { padding: [50, 50], duration: 1.0 });
        }
        
        updateMapDisplay();
        renderCases();
        renderRoutes();
        renderHotspots();
    };

    function clearIsolation() {
        isolatedClusterCaseIds = null;
        document.getElementById("btnClearIsolation").style.display = "none";
        updateMapDisplay();
        renderCases();
        renderRoutes();
        renderHotspots();
    }

    document.getElementById("btnClearIsolation").addEventListener("click", clearIsolation);
    document.getElementById("searchBuffer").addEventListener("input", updateMapDisplay);
    document.getElementById("hideUnused").addEventListener("change", updateMapDisplay); 
    document.getElementById("btnReset").addEventListener("click", resetDemo);
    document.getElementById("btnRoute").addEventListener("click", runRouting);
    document.getElementById("showRoutes").addEventListener("change", renderRoutes);
    document.getElementById("showHotspots").addEventListener("change", renderHotspots);
    
    document.getElementById("clusterMode").addEventListener("change", () => {
        renderCases();
        renderRoutes();
        renderHotspots();
    });
    
    document.getElementById("triRed").addEventListener("change", () => { buildClusters(); renderCases(); renderRoutes(); renderHotspots(); });
    document.getElementById("triYellow").addEventListener("change", () => { buildClusters(); renderCases(); renderRoutes(); renderHotspots(); });
    document.getElementById("triGreen").addEventListener("change", () => { buildClusters(); renderCases(); renderRoutes(); renderHotspots(); });

    document.getElementById("lblRed").addEventListener("click", () => {
      document.getElementById("triRed").checked = true;
      document.getElementById("triYellow").checked = false;
      document.getElementById("triGreen").checked = false;
      buildClusters();
      renderCases(); 
      renderRoutes();
      renderHotspots();
    });

    document.getElementById("lblYellow").addEventListener("click", () => {
      document.getElementById("triRed").checked = false;
      document.getElementById("triYellow").checked = true;
      document.getElementById("triGreen").checked = false;
      buildClusters();
      renderCases(); 
      renderRoutes();
      renderHotspots();
    });

    document.getElementById("lblGreen").addEventListener("click", () => {
      document.getElementById("triRed").checked = false;
      document.getElementById("triYellow").checked = false;
      document.getElementById("triGreen").checked = true;
      buildClusters();
      renderCases(); 
      renderRoutes();
      renderHotspots();
    });

    map.on('zoomend', () => {
      updateMapDisplay();
      renderCases();
      renderRoutes(); 
      renderHotspots();
    });

    loadAllData();
    refreshHealthsitesStatus().then(() => attachHealthsitesLayers());

  </script>
</body>
</html>