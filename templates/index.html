<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>NATO Med Interop Demo — Real-time Facility Routing</title>

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet.vectorgrid@1.3.0/dist/Leaflet.VectorGrid.bundled.js"></script>
  <script src="https://unpkg.com/leaflet-polylinedecorator/dist/leaflet.polylineDecorator.js"></script>

  <style>
    html, body { height: 100%; margin: 0; background: #f0f2f5; }
    #map { height: 100%; width: 100%; }

    /* Sidebar */
    .sidebar {
      position: absolute;
      top: 15px; left: 15px;
      z-index: 1000;
      width: 370px;
      max-width: calc(100vw - 30px);
      background: rgba(255,255,255,0.98);
      border-radius: 12px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.15), 0 1px 3px rgba(0,0,0,0.05);
      font: 14px/1.3 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      overflow: hidden;
      backdrop-filter: blur(8px);
    }
    .sidebar header {
      padding: 14px 16px;
      border-bottom: 1px solid rgba(0,0,0,0.08);
      background: linear-gradient(to bottom, #ffffff, #f8fafc);
      display:flex;
      gap:10px;
      align-items:baseline;
      justify-content:space-between;
    }
    .sidebar header b { font-size: 15px; color: #1e293b; }
    .sidebar header small { opacity: 0.75; color: #475569; display: block; margin-top: 2px;}
    .sidebar .content { padding: 14px 16px; }
    .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .row + .row { margin-top: 12px; }
    
    /* Enhanced Button Styles */
    button {
      appearance: none;
      border: 1px solid rgba(0,0,0,0.15);
      background: #fff;
      border-radius: 8px;
      padding: 8px 12px;
      cursor: pointer;
      box-shadow: 0 2px 4px rgba(0,0,0,0.03);
      font-weight: 600;
      color: #334155;
      transition: all 0.2s ease;
    }
    button:hover:not(:disabled) {
      background: #f8fafc;
      border-color: rgba(0,0,0,0.25);
    }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    
    .btn-primary {
      background: #0078D7;
      color: #fff;
      border: none;
      box-shadow: 0 3px 8px rgba(0, 120, 215, 0.3);
    }
    .btn-primary:hover:not(:disabled) {
      background: #005a9e;
      color: #fff;
    }

    /* Styled Pills */
    .pill {
      border: 1px solid rgba(0,0,0,0.14);
      border-radius: 999px;
      padding: 5px 10px;
      background: #f1f5f9;
      font-size: 12.5px;
      color: #475569;
      display: inline-flex;
      align-items: center;
      gap: 5px;
      transition: all 0.2s ease;
    }
    .pill:hover { background: #e2e8f0; }
    
    /* Color-Coded Triage Filters */
    .pill-red { background: #fee2e2; border-color: #fca5a5; color: #991b1b; }
    .pill-red:hover { background: #fecaca; }
    .pill-red input[type="checkbox"] { accent-color: #dc2626; }

    .pill-yellow { background: #fef3c7; border-color: #fcd34d; color: #92400e; }
    .pill-yellow:hover { background: #fde68a; }
    .pill-yellow input[type="checkbox"] { accent-color: #d97706; }

    .pill-green { background: #dcfce7; border-color: #86efac; color: #166534; }
    .pill-green:hover { background: #bbf7d0; }
    .pill-green input[type="checkbox"] { accent-color: #16a34a; }

    .pill input[type="checkbox"] { margin: 0; cursor: pointer; }

    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    .hr { height:1px; background: rgba(0,0,0,0.08); margin: 14px 0; }

    /* Summary Card */
    #summary {
      background: #f8fafc;
      border: 1px solid #e2e8f0;
      border-radius: 8px;
      padding: 12px;
    }
    #summary .kv { display: flex; justify-content: space-between; margin-bottom: 6px; align-items: center; }
    #summary .kv:last-child { margin-bottom: 0; border-top: 1px solid #e2e8f0; padding-top: 6px; margin-top: 6px; }
    .k { font-weight: 600; color: #475569; }
    #summary span:not(.k) { font-weight: 700; color: #0f172a; }

    label { cursor: pointer; user-select: none; }

    .status-ok { color: #059669; font-weight: 700; background: #d1fae5; border-color: #6ee7b7;}
    .status-warn { color: #d97706; font-weight: 700; background: #fef3c7; border-color: #fcd34d;}

    /* Slider specific styling */
    .slider-row { width: 100%; display: flex; flex-direction: column; gap: 4px; }
    .slider-row .pill { width: 100%; box-sizing: border-box; display: flex; flex-direction: row; justify-content: space-between; align-items: center;}
    #searchBuffer { flex-grow: 1; margin-left: 10px; cursor: pointer; accent-color: #0078D7; }

    /* Icon Styling */
    .custom-man-icon { background: none; border: none; }
  </style>
</head>

<body>
  <div class="sidebar">
    <header>
      <div>
        <b>Medical Resource Exchange — Demo</b><br/>
        <small>Goal: “right patient → right facility → right time”</small>
      </div>
      <div class="pill mono" id="hsStatus">healthsites: ?</div>
    </header>

    <div class="content">

      <div class="row">
        <span class="pill pill-red"><input id="triRed" type="checkbox" checked /> <label id="lblRed">Immediate (Red)</label></span>
        <span class="pill pill-yellow"><input id="triYellow" type="checkbox" checked /> <label id="lblYellow">Delayed (Yellow)</label></span>
        <span class="pill pill-green"><input id="triGreen" type="checkbox" checked /> <label id="lblGreen">Minimal (Green)</label></span>
      </div>
      
      <div class="row slider-row">
        <label class="pill">
          <span>Search Radius: <b id="radiusDisplay">1.5</b>°</span>
          <input id="searchBuffer" type="range" step="0.1" value="1.5" min="0.5" max="10.0">
        </label>
      </div>

      <div class="row" style="margin-top: 16px;">
        <button id="btnRoute" class="btn-primary">Run MASCAL Routing</button>
        <button id="btnClearIsolation" style="display:none; color: #dc2626; border-color: #fca5a5; background: #fee2e2;">Clear Isolation</button>
      </div>

      <div class="row">
        <span class="pill"><input id="showRoutes" type="checkbox" checked /> <label for="showRoutes">Show routes</label></span>
        <span class="pill"><input id="showHotspots" type="checkbox" checked /> <label for="showHotspots">Hotspots</label></span>
        <span class="pill"><input id="clusterMode" type="checkbox" /> <label for="clusterMode">Cluster Mode</label></span>
        <span class="pill"><input id="hideUnused" type="checkbox" /> <label for="hideUnused">Hide unused</label></span>
      </div>

      <div class="hr"></div>

      <div id="summary">
        <div class="kv"><span class="k">Hospitals in Radius:</span> <span id="facCount">–</span></div>
        <div class="kv"><span class="k">Active Casualties:</span> <span id="caseCount">–</span></div>
        <div class="kv"><span class="k">Routing Result:</span> <span id="routeSummary" style="color:#0078D7;">Ready</span></div>
      </div>

      <div style="opacity:0.7; font-size:12px; margin-top: 12px; text-align: center;">
        Note: Pre-loads up to 10° on startup. Adjust slider for real-time visualization.
      </div>
    </div>
  </div>

  <div id="map"></div>

  <script>
    // --- TUNABLE VARIABLE ---
    const MAX_LOAD_RADIUS = 10.0; 

    const map = L.map('map', { 
      center: [56.9, 23.7], 
      zoom: 7, 
      preferCanvas: true, // Uses HTML5 Canvas for high performance
      zoomControl: false
    });

    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19, 
      attribution: '&copy; OpenStreetMap contributors',
      updateWhenIdle: false, // Loads tiles immediately while panning
      keepBuffer: 10         // Keeps more tiles loaded outside the visible view
    }).addTo(map);

    // Using FeatureGroup instead of LayerGroup gives us bringToFront() and bringToBack() for canvas ordering
    const demoHotspotsLayer = L.featureGroup().addTo(map);
    const demoRoutesLayer = L.featureGroup().addTo(map);
    const demoFacilitiesLayer = L.featureGroup().addTo(map);
    const demoCasesLayer = L.featureGroup().addTo(map);

    // --- OVERLAPPING ROUTES HANDLER ---
    // When the map is clicked, scan ALL rendered routes to see which ones are underneath the cursor.
    // This allows us to combine overlapping road networks into a single cohesive patient manifest.
    demoRoutesLayer.on('click', function(e) {
        const clickPoint = map.latLngToLayerPoint(e.latlng);
        let combinedPatients = new Map();
        let destinations = new Set();
        
        demoRoutesLayer.eachLayer((layer) => {
            // Only process our invisible "hit lines"
            if (layer.isHitLine && layer.routeData) {
                const latlngs = layer.getLatLngs();
                if (!latlngs || latlngs.length < 2) return;
                
                let minDist = Infinity;
                // Calculate distance from cursor to every segment of the polyline
                for (let i = 0; i < latlngs.length - 1; i++) {
                    const p1 = map.latLngToLayerPoint(latlngs[i]);
                    const p2 = map.latLngToLayerPoint(latlngs[i+1]);
                    const dist = L.LineUtil.pointToSegmentDistance(clickPoint, p1, p2);
                    if (dist < minDist) minDist = dist;
                }
                
                // If the cursor is within 15 pixels of the line, it's a hit
                if (minDist <= 15) {
                    destinations.add(layer.routeData.facility_name);
                    layer.routeData.patients.forEach(p => {
                        // Using a Map with case_id prevents duplicating patients if geometries glitch
                        combinedPatients.set(p.case_id, p);
                    });
                }
            }
        });

        if (combinedPatients.size > 0) {
            // Sort patients by severity (Red -> Yellow -> Green) for display
            const pts = Array.from(combinedPatients.values()).sort((a,b) => {
                const svA = a.nato_triage.toLowerCase().includes("red") ? 3 : (a.nato_triage.toLowerCase().includes("yellow") ? 2 : 1);
                const svB = b.nato_triage.toLowerCase().includes("red") ? 3 : (b.nato_triage.toLowerCase().includes("yellow") ? 2 : 1);
                return svB - svA; 
            });
            
            let destStr = Array.from(destinations).join(', ');

            const popupHTML = `
              <div style="font:13px/1.25 system-ui,sans-serif; min-width: 250px;">
                <div style="margin-bottom: 6px; padding-bottom: 4px; border-bottom: 1px solid #eee;">
                  <b style="font-size: 14px;">Traffic on this Route Segment</b>
                </div>
                <div class="kv"><span class="k mono">Destinations:</span> ${destStr}</div>
                <div class="kv" style="margin-top: 6px;"><span class="k mono">Patients Traveling (${pts.length}):</span></div>
                <div style="max-height: 150px; overflow-y: auto; margin-top:4px; font-size: 11.5px; background: rgba(0,0,0,0.02); padding: 4px; border-radius: 4px;">
                  ${pts.map(p => {
                     const pCol = triageColor(p.nato_triage);
                     const distStr = p.distance_km ? ` (${p.distance_km.toFixed(1)} km)` : '';
                     return `<div onclick="showPatient(${p.case_id})" title="Click for patient details" style="margin-bottom:3px; padding-bottom: 3px; border-bottom: 1px solid rgba(0,0,0,0.05); cursor: pointer; transition: background 0.2s;" onmouseover="this.style.background='rgba(0,0,0,0.05)'" onmouseout="this.style.background='transparent'">
                               <b style="color:${pCol}; font-size: 14px; line-height: 10px;">&bull;</b> 
                               <span style="color: #0078D7; text-decoration: underline;"><b>Case ${p.case_id}</b></span> &mdash; ${p.nato_triage}${distStr}
                             </div>`;
                  }).join('')}
                </div>
              </div>
            `;

            L.popup({ autoPan: false })
             .setLatLng(e.latlng)
             .setContent(popupHTML)
             .openOn(map);
        }
    });

    let healthsitesWays = null;
    let healthsitesNodes = null;
    
    // Client-side Data Cache
    let allFacilitiesFeatures = []; 
    let currentCases = [];
    let currentRoutes = [];
    let casualtyBounds = null; 
    let assignedFacilityIds = new Set(); 
    let assignedPatientsByFacility = {}; 
    let activeClusters = [];
    
    // Isolation State
    let isolatedClusterCaseIds = null;

    // --- OSRM Routing Queue for Road-snapping ---
    let osrmQueue = [];
    let osrmCache = {}; 
    let isFetchingOsrm = false;
    let osrmGeneration = 0;

    async function processOsrmQueue(generation) {
        if (isFetchingOsrm) return;
        isFetchingOsrm = true;

        const summaryEl = document.getElementById("routeSummary");
        let baseSummary = summaryEl.innerHTML.split('<br>')[0];

        let totalTasks = osrmQueue.length;
        let processed = 0;

        while (osrmQueue.length > 0) {
            if (generation !== osrmGeneration) break;

            const task = osrmQueue.shift();
            processed++;

            if (!demoRoutesLayer.hasLayer(task.visualLine)) continue;

            try {
                const startKey = `${task.start[0].toFixed(3)},${task.start[1].toFixed(3)}`;
                const endKey = `${task.end[0].toFixed(3)},${task.end[1].toFixed(3)}`;
                const cacheKey = `${startKey}|${endKey}`;

                if (osrmCache[cacheKey] === "FETCHING") {
                    osrmQueue.push(task); 
                    await new Promise(r => setTimeout(r, 100));
                    continue;
                }

                if (osrmCache[cacheKey]) {
                    if (osrmCache[cacheKey] !== "NOROUTE" && osrmCache[cacheKey] !== "FETCHING") {
                        task.visualLine.setLatLngs(osrmCache[cacheKey]);
                        if (task.hitLine) task.hitLine.setLatLngs(osrmCache[cacheKey]);
                    }
                    continue;
                }

                osrmCache[cacheKey] = "FETCHING";

                if (processed % 2 === 0 || processed === 1) {
                    const pct = Math.round((processed / totalTasks) * 100);
                    summaryEl.innerHTML = `${baseSummary}<br><small style="color:#b60;">Snapping to roads... ${pct}%</small>`;
                }

                const url = `https://router.project-osrm.org/route/v1/driving/${task.start[0]},${task.start[1]};${task.end[0]},${task.end[1]}?overview=simplified&geometries=geojson`;
                const res = await fetch(url);
                
                if (res.status === 429) {
                    osrmCache[cacheKey] = null; 
                    osrmQueue.unshift(task); 
                    processed--; 
                    console.warn("OSRM API rate limit hit. Waiting 2.5s...");
                    await new Promise(r => setTimeout(r, 2500));
                    continue;
                }

                if (!res.ok) {
                    console.warn(`OSRM failed (HTTP ${res.status}). Coordinates: ${cacheKey}`);
                    osrmCache[cacheKey] = "NOROUTE";
                    continue;
                }

                const data = await res.json();
                let roadCoords = "NOROUTE";
                
                if (data.code === "Ok" && data.routes && data.routes.length > 0) {
                    roadCoords = data.routes[0].geometry.coordinates.map(c => [c[1], c[0]]);
                }
                
                osrmCache[cacheKey] = roadCoords;
                
                fetch("/api/demo/osrm_cache", {
                    method: "POST",
                    headers: {"Content-Type": "application/json"},
                    body: JSON.stringify({ [cacheKey]: roadCoords })
                }).catch(e => console.warn("Cache save failed", e));
                
                if (roadCoords !== "NOROUTE") {
                    task.visualLine.setLatLngs(roadCoords);
                    if (task.hitLine) task.hitLine.setLatLngs(roadCoords);
                }

                await new Promise(r => setTimeout(r, 150));

            } catch (e) {
                console.error("OSRM Routing iteration failed:", e);
            }
        }
        
        isFetchingOsrm = false;
        
        if (generation === osrmGeneration) {
            summaryEl.innerHTML = `${baseSummary}<br><small style="color:#0a7; font-weight:bold;">Road snapping complete</small>`;
        }
    }

    function enforceZOrder() {
        if (map.hasLayer(demoHotspotsLayer)) demoHotspotsLayer.bringToBack();
        if (map.hasLayer(demoRoutesLayer)) demoRoutesLayer.bringToBack();
        if (map.hasLayer(demoFacilitiesLayer)) demoFacilitiesLayer.bringToFront();
        if (map.hasLayer(demoCasesLayer)) demoCasesLayer.bringToFront(); 
    }

    function triageColor(triage) {
      const t = (triage || "").toLowerCase();
      if (t.includes("red") || t.includes("immediate")) return "#dc2626";
      if (t.includes("yellow") || t.includes("delayed")) return "#d97706";
      return "#16a34a";
    }

    function facilityColor(bedsAvailable, bedsTotal) {
      const tot = Math.max(1, Number(bedsTotal || 1));
      const av = Math.max(0, Number(bedsAvailable || 0));
      const ratio = av / tot;
      if (ratio <= 0.05) return "#b11";
      if (ratio <= 0.15) return "#b60";
      if (ratio <= 0.30) return "#c9b200";
      return "#0a7";
    }

    function facilityRadius(role, zoom) {
      const r = (role || "").toLowerCase();
      let baseSize = 2; 
      if (r.includes("role4")) baseSize = 5; 
      else if (r.includes("role3")) baseSize = 3; 
      else if (r.includes("role2")) baseSize = 2; 

      return Math.max(0.5, baseSize * Math.pow(1.15, zoom - 7));
    }

    function getManIcon(color, size) {
      return L.divIcon({
        className: 'custom-man-icon',
        html: `<svg viewBox="0 0 960 960" width="${size}" height="${size}">
                 <path fill="${color}" d="M400,840v-240h-40q-17,0 -28.5,-11.5T320,560v-200q0,-33 23.5,-56.5T400,280h160q33,0 56.5,23.5T640,360v200q0,17 -11.5,28.5T600,600h-40v240q0,17 -11.5,28.5T520,880h-80q-17,0 -28.5,-11.5T400,840Zm80,-600q-33,0 -56.5,-23.5T400,160q0,-33 23.5,-56.5T480,80q33,0 56.5,23.5T560,160q0,33 -23.5,56.5T480,240Z" />
               </svg>`,
        iconSize: [size, size],
        iconAnchor: [size / 2, size]
      });
    }

    function popupTable(props, keys, facId = null) {
      let incoming = facId ? (assignedPatientsByFacility[facId] || []) : [];
      let totalIncoming = incoming.length;
      let icuIncoming = incoming.filter(c => (c.nato_triage||"").toLowerCase().includes("red")).length;

      let html = '<div style="font:13px/1.25 system-ui,sans-serif; min-width: 220px;">';
      for (const k of keys) {
        const v = props ? props[k] : null;
        if (v === undefined || v === null) continue;

        if (k === "capacity" && typeof v === "object") {
          html += `<div style="margin-top: 8px; padding-top: 4px; border-top: 1px solid #eee;">`;
          html += `<span class="k" style="text-transform: uppercase; font-size: 11px; color: #666;">Capacity Status</span>`;
          html += `<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 4px; margin-top: 4px;">`;
          
          const bedAdd = totalIncoming > 0 ? ` <span style="color:#0078D7; font-weight:bold;" title="Newly assigned patients">+ ${totalIncoming}</span>` : "";
          const icuAdd = icuIncoming > 0 ? ` <span style="color:#0078D7; font-weight:bold;" title="Newly assigned ICU patients">+ ${icuIncoming}</span>` : "";

          html += `<div class="kv">Beds: <b>${v.beds_available}/${v.beds_total}</b>${bedAdd}</div>`;
          html += `<div class="kv">ICU: <b>${v.icu_available}/${v.icu_total}</b>${icuAdd}</div>`;
          html += `<div class="kv">Vents: <b>${v.vent_available}/${v.vent_total}</b>${icuAdd}</div>`;
          html += `</div></div>`;
        } else if (Array.isArray(v)) {
          if (!v.length) continue;
          html += `<div class="kv"><span class="k mono">${k}</span>: ${v.join(", ")}</div>`;
        } else {
          const s = String(v).trim();
          if (!s) continue;
          html += `<div class="kv"><span class="k mono">${k}</span>: ${s}</div>`;
        }
      }

      if (totalIncoming > 0) {
          html += `<div style="margin-top: 8px; padding-top: 4px; border-top: 1px solid #eee;">`;
          html += `<span class="k" style="text-transform: uppercase; font-size: 11px; color: #666;">Incoming Patients (${totalIncoming})</span>`;
          html += `<div style="max-height: 120px; overflow-y: auto; margin-top:4px; font-size: 11.5px; background: rgba(0,0,0,0.02); padding: 4px; border-radius: 4px;">`;
          incoming.forEach(p => {
              const tColor = triageColor(p.nato_triage);
              html += `<div onclick="showPatient(${p.case_id})" title="Click for patient details" style="margin-bottom:3px; padding-bottom: 3px; border-bottom: 1px solid rgba(0,0,0,0.05); cursor: pointer; transition: background 0.2s;" onmouseover="this.style.background='rgba(0,0,0,0.05)'" onmouseout="this.style.background='transparent'">
                         <b style="color:${tColor}; font-size: 14px; line-height: 10px;">&bull;</b> 
                         <span style="color: #0078D7; text-decoration: underline;"><b>Case ${p.case_id}</b></span> &mdash; ${p.nato_triage}
                       </div>`;
          });
          html += `</div></div>`;
      }

      html += '</div>';
      return html;
    }

    window.showPatient = function(caseId) {
        // Prevent the click from registering on the map and closing the popup
        if (window.event) window.event.stopPropagation();
        
        const patient = currentCases.find(c => c.properties.case_id === caseId);
        
        // Find the patient's routing assignment, if one exists
        const assignment = currentRoutes.find(r => r.case_id === caseId);
        
        if (patient) {
            const keysToShow = [
                "case_id", "name", "age", "sex", "branch", 
                "nato_triage", "diagnosis", "evacuation_recommendation"
            ];
            
            setTimeout(() => {
                let activePopup = map._popup;
                if (activePopup) {
                    if (!activePopup._previousContent) {
                        activePopup._previousContent = activePopup.getContent();
                    }

                    // Base patient info table
                    let patientHtml = popupTable(patient.properties, keysToShow);
                    
                    // Add Assignment Information
                    let assignmentHtml = '';
                    if (assignment) {
                        assignmentHtml = `
                          <div style="margin-top: 8px; padding-top: 4px; border-top: 1px solid #eee;">
                            <span class="k" style="text-transform: uppercase; font-size: 11px; color: #666;">Evacuation Assignment</span>
                            <div class="kv"><span class="k mono">Destination</span>: <b>${assignment.facility_name}</b></div>
                            <div class="kv"><span class="k mono">Reason</span>: ${assignment.reason}</div>
                            <div class="kv"><span class="k mono">Est. Dist.</span>: ${assignment.distance_km.toFixed(1)} km</div>
                          </div>
                        `;
                    } else {
                        assignmentHtml = `
                          <div style="margin-top: 8px; padding-top: 4px; border-top: 1px solid #eee;">
                            <span class="k" style="text-transform: uppercase; font-size: 11px; color: #666;">Evacuation Assignment</span>
                            <div class="kv"><span style="color: #b60; font-weight: bold;">Unassigned / Pending</span></div>
                          </div>
                        `;
                    }

                    const newContent = `
                      <div style="margin-bottom: 8px; border-bottom: 1px solid #eee; padding-bottom: 8px;">
                        <button onclick="window.restorePopup(event)" style="padding: 4px 8px; font-size: 12px; cursor: pointer; border: 1px solid #ccc; background: #fff; border-radius: 4px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); font-weight: bold;">
                          &larr; Back
                        </button>
                      </div>
                      ${patientHtml}
                      ${assignmentHtml}
                    `;

                    activePopup.setContent(newContent);
                    activePopup.update();
                }
            }, 10);
        }
    };

    window.restorePopup = function(e) {
        if (e) e.stopPropagation();
        if (window.event) window.event.stopPropagation();
        
        setTimeout(() => {
            let activePopup = map._popup;
            if (activePopup && activePopup._previousContent) {
                activePopup.setContent(activePopup._previousContent);
                activePopup.update();
                activePopup._previousContent = null;
            }
        }, 10);
    };

    function getEdgeCoord(centerLat, centerLon, destLat, destLon, radiusMeters) {
        const R = 6378137; 
        const dLat = (destLat - centerLat) * Math.PI / 180;
        const dLon = (destLon - centerLon) * Math.PI / 180;
        const lat1 = centerLat * Math.PI / 180;
        const lat2 = destLat * Math.PI / 180;

        const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                Math.sin(dLon/2) * Math.sin(dLon/2) * Math.cos(lat1) * Math.cos(lat2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        const distance = R * c;

        if (distance === 0 || distance <= radiusMeters) return [centerLat, centerLon];

        const ratio = radiusMeters / distance;
        return [
            centerLat + (destLat - centerLat) * ratio,
            centerLon + (destLon - centerLon) * ratio
        ];
    }

    function buildClusters() {
        activeClusters = [];
        const showRed = document.getElementById("triRed").checked;
        const showYellow = document.getElementById("triYellow").checked;
        const showGreen = document.getElementById("triGreen").checked;
        const CLUSTER_THRESHOLD_METERS = 2000;

        currentCases.forEach(f => {
            const triage = (f.properties.nato_triage || "").toLowerCase();
            let isRed = false, isYellow = false, isGreen = false;
            
            if (triage.includes("red") || triage.includes("immediate")) isRed = true;
            else if (triage.includes("yellow") || triage.includes("delayed")) isYellow = true;
            else if (triage.includes("green") || triage.includes("minimal")) isGreen = true;

            const lat = f.geometry.coordinates[1];
            const lon = f.geometry.coordinates[0];
            let foundCluster = null;
            let minD = Infinity;

            for (const c of activeClusters) {
                const d = map.distance([lat, lon], [c.lat, c.lon]);
                if (d < CLUSTER_THRESHOLD_METERS && d < minD) {
                    minD = d;
                    foundCluster = c;
                }
            }

            if (foundCluster) {
                foundCluster.lat = ((foundCluster.lat * foundCluster.totalCount) + lat) / (foundCluster.totalCount + 1);
                foundCluster.lon = ((foundCluster.lon * foundCluster.totalCount) + lon) / (foundCluster.totalCount + 1);
                foundCluster.totalCount++;
                foundCluster.cases.push(f.properties.case_id);
                
                if (isRed) foundCluster.redCount++;
                if (isYellow) foundCluster.yellowCount++;
                if (isGreen) foundCluster.greenCount++;
            } else {
                activeClusters.push({ 
                    lat: lat, lon: lon, totalCount: 1, cases: [f.properties.case_id],
                    redCount: isRed ? 1 : 0,
                    yellowCount: isYellow ? 1 : 0,
                    greenCount: isGreen ? 1 : 0
                });
            }
        });

        activeClusters = activeClusters.filter(c => {
            c.visibleCount = 0;
            c.severity = 1;
            
            if (showRed && c.redCount > 0) { 
                c.visibleCount += c.redCount; 
                c.severity = 3; 
            }
            if (showYellow && c.yellowCount > 0) { 
                c.visibleCount += c.yellowCount; 
                if (c.severity < 3) c.severity = 2; 
            }
            if (showGreen && c.greenCount > 0) { 
                c.visibleCount += c.greenCount; 
            }
            
            return c.totalCount > 4 && c.visibleCount > 0;
        });

        activeClusters.forEach(c => {
            c.count = c.visibleCount; 
            c.radiusMeters = 2000 + (c.visibleCount * 800); 
            
            if (c.severity === 3) c.color = "#dc2626";
            else if (c.severity === 2) c.color = "#d97706";
            else c.color = "#16a34a";
        });
    }

    async function refreshHealthsitesStatus() {
      const el = document.getElementById("hsStatus");
      try {
        const r = await fetch("/api/healthsites/status");
        const j = await r.json();
        if (j.healthsites_available) {
          el.textContent = "healthsites: ON";
          el.className = "pill mono status-ok";
          attachHealthsitesLayers();
        } else {
          el.textContent = "healthsites: OFF";
          el.className = "pill mono status-warn";
        }
      } catch (e) {
        el.textContent = "healthsites: ?";
        el.className = "pill mono status-warn";
      }
    }

    function attachHealthsitesLayers() {
      if (healthsitesWays || healthsitesNodes) return;
      const gridOpts = { updateWhenIdle: false, keepBuffer: 10 };

      healthsitesWays = L.vectorGrid.protobuf('/tiles/ways/{z}/{x}/{y}.pbf', {
        ...gridOpts,
        vectorTileLayerStyles: {
          ways: function(props, zoom) { return { weight: zoom >= 12 ? 2 : 1, fill: true, fillOpacity: 0.12, opacity: 0.8 }; }
        },
        interactive: true,
        getFeatureId: f => (f.properties && (f.properties.upstream_id)) || null,
        maxNativeZoom: 14
      });

      healthsitesNodes = L.vectorGrid.protobuf('/tiles/nodes/{z}/{x}/{y}.pbf', {
        ...gridOpts,
        minZoom: 11,
        vectorTileLayerStyles: {
          nodes: function(props, zoom) {
            const r = zoom >= 14 ? 6 : (zoom >= 12 ? 4 : 3);
            return { radius: r, fill: true, fillOpacity: 0.65, weight: 1, opacity: 1 };
          }
        },
        interactive: true,
        getFeatureId: f => (f.properties && (f.properties.upstream_id)) || null,
        maxNativeZoom: 14
      });

      const popupOrder = ["name","health_facility:type","amenity","healthcare","bed_count","opening_hours","operator","contact:phone","website"];

      function showVTpopup(e) {
        const props = e.layer && e.layer.properties;
        L.popup({ autoPan: false }).setLatLng(e.latlng).setContent(popupTable(props, popupOrder)).openOn(map);
      }
      healthsitesWays.on('click', showVTpopup);
      healthsitesNodes.on('click', showVTpopup);

      L.control.layers({}, {
        "Hospitals (Real-time Simulation)": demoFacilitiesLayer,
        "MASCAL Casualties": demoCasesLayer,
        "Crisis Hotspots": demoHotspotsLayer,
        "Evacuation Routes": demoRoutesLayer,
        "Healthsites (Base Layers)": healthsitesWays,
        "Healthsites (Points)": healthsitesNodes
      }, { collapsed: true }).addTo(map);
    }

    async function loadAllData() {
        const routeSummaryEl = document.getElementById("routeSummary");
        routeSummaryEl.textContent = "Loading data...";

        try {
            try {
                const cacheRes = await fetch("/api/demo/osrm_cache");
                if (cacheRes.ok) {
                    const serverCache = await cacheRes.json();
                    osrmCache = { ...serverCache, ...osrmCache };
                }
            } catch(e) { console.warn("Failed to load OSRM cache from server", e); }

            const caseRes = await fetch("/api/demo/cases");
            const caseFc = await caseRes.json();
            currentCases = caseFc.features || [];

            if (currentCases.length > 0) {
                const lons = currentCases.map(f => f.geometry.coordinates[0]);
                const lats = currentCases.map(f => f.geometry.coordinates[1]);
                casualtyBounds = {
                    minLon: Math.min(...lons), maxLon: Math.max(...lons),
                    minLat: Math.min(...lats), maxLat: Math.max(...lats)
                };
            }

            const facRes = await fetch(`/api/demo/facilities?buffer=${MAX_LOAD_RADIUS}`);
            const facFc = await facRes.json();
            allFacilitiesFeatures = facFc.features || [];

            buildClusters();
            
            renderCases();
            renderHotspots();
            updateMapDisplay(); 
            routeSummaryEl.textContent = "Ready";
        } catch (err) {
            console.error("Load failed", err);
            routeSummaryEl.textContent = "Load Error";
        }
    }

    function updateMapDisplay() {
        const bufferVal = parseFloat(document.getElementById("searchBuffer").value);
        const hideUnused = document.getElementById("hideUnused").checked; 
        const currentZoom = map.getZoom(); 
        document.getElementById("radiusDisplay").textContent = bufferVal.toFixed(1);
        
        let activeIsolatedFacilities = new Set();
        if (isolatedClusterCaseIds) {
            currentRoutes.forEach(r => {
                if (isolatedClusterCaseIds.has(r.case_id) && r.facility_id) {
                    activeIsolatedFacilities.add(String(r.facility_id));
                }
            });
        }
        
        demoFacilitiesLayer.clearLayers();
        if (!casualtyBounds) return;

        let count = 0;
        allFacilitiesFeatures.forEach(f => {
            const [lon, lat] = f.geometry.coordinates;
            const p = f.properties || {};
            const facId = String(p.facility_id);

            const inBounds = (lon >= casualtyBounds.minLon - bufferVal && lon <= casualtyBounds.maxLon + bufferVal &&
                              lat >= casualtyBounds.minLat - bufferVal && lat <= casualtyBounds.maxLat + bufferVal);
            
            const isUsed = assignedFacilityIds.has(facId);
            let shouldShow = inBounds && (!hideUnused || isUsed);

            if (isolatedClusterCaseIds) {
                shouldShow = activeIsolatedFacilities.has(facId);
            }

            if (shouldShow) {
                const cap = p.capacity || {};
                const c = facilityColor(cap.beds_available, cap.beds_total);
                const rad = facilityRadius(p.role_of_care, currentZoom);

                const mVisual = L.circleMarker([lat, lon], {
                    radius: rad, color: "#111", weight: 1, fillColor: c, fillOpacity: 0.9, interactive: false
                });

                const mHit = L.circleMarker([lat, lon], {
                    radius: Math.max(10, rad + 6), color: "transparent", weight: 0, fillColor: "transparent", fillOpacity: 0, interactive: true
                }).bindPopup(popupTable(p, ["facility_id","name","role_of_care","specialties","capacity"], facId), { autoPan: false });
                
                mVisual.addTo(demoFacilitiesLayer);
                mHit.addTo(demoFacilitiesLayer);
                count++;
            }
        });
        document.getElementById("facCount").textContent = count;
        enforceZOrder();
    }

    function renderCases() {
      demoCasesLayer.clearLayers();
      
      if (document.getElementById("clusterMode").checked) {
          enforceZOrder();
          return; 
      }

      const currentZoom = map.getZoom();
      const showRed = document.getElementById("triRed").checked;
      const showYellow = document.getElementById("triYellow").checked;
      const showGreen = document.getElementById("triGreen").checked;

      let count = 0;
      currentCases.forEach(f => {
        if (isolatedClusterCaseIds && !isolatedClusterCaseIds.has(f.properties.case_id)) return;

        const triage = (f.properties.nato_triage || "").toLowerCase();
        let isVisible = false;
        if (showRed && (triage.includes("red") || triage.includes("immediate"))) isVisible = true;
        if (showYellow && (triage.includes("yellow") || triage.includes("delayed"))) isVisible = true;
        if (showGreen && (triage.includes("green") || triage.includes("minimal"))) isVisible = true;

        if (isVisible) {
          const c = triageColor(f.properties.nato_triage);
          const dynamicSize = Math.max(12, 24 * Math.pow(1.2, currentZoom - 7));
          
          const patientKeys = [
              "case_id", "name", "age", "sex", "branch", 
              "nato_triage", "diagnosis", "evacuation_recommendation"
          ];
          
          L.marker([f.geometry.coordinates[1], f.geometry.coordinates[0]], {
            icon: getManIcon(c, dynamicSize)
          }).bindPopup(popupTable(f.properties, patientKeys), { autoPan: false })
            .addTo(demoCasesLayer);
          
          count++;
        }
      });
      document.getElementById("caseCount").textContent = count;
      enforceZOrder();
    }

    function getCircleCoords(lat, lon, radiusMeters, points = 64) {
        const coords = [];
        const R = 6378137; 
        const d = radiusMeters / R;
        const lat1 = lat * Math.PI / 180;
        const lon1 = lon * Math.PI / 180;

        for (let i = 0; i <= points; i++) {
            const brng = (i / points) * 2 * Math.PI;
            const lat2 = Math.asin(Math.sin(lat1) * Math.cos(d) + Math.cos(lat1) * Math.sin(d) * Math.cos(brng));
            const lon2 = lon1 + Math.atan2(Math.sin(brng) * Math.sin(d) * Math.cos(lat1), Math.cos(d) - Math.sin(lat1) * Math.sin(lat2));
            coords.push([lat2 * 180 / Math.PI, lon2 * 180 / Math.PI]);
        }
        return coords;
    }

    function renderHotspots(preventReopen = false) {
      // 1. Capture the currently open cluster popup before clearing layers
      let openClusterIndex = null;
      // Added .isOpen() to guarantee we only restore popups that are actually visible
      if (!preventReopen && map && map._popup && map._popup.isOpen() && map._popup.options && 'clusterIndex' in map._popup.options) {
          openClusterIndex = map._popup.options.clusterIndex;
      }

      demoHotspotsLayer.clearLayers();
      
      if (!document.getElementById("showHotspots").checked && !document.getElementById("clusterMode").checked) {
          enforceZOrder();
          return;
      }

      const showRed = document.getElementById("triRed").checked;
      const showYellow = document.getElementById("triYellow").checked;
      const showGreen = document.getElementById("triGreen").checked;
      
      // Keep track of the newly generated polygons to re-attach the popup
      let clusterPolygons = {};

      activeClusters.forEach((c, index) => {
        if (isolatedClusterCaseIds) {
            const hasIsolated = c.cases.some(id => isolatedClusterCaseIds.has(id));
            if (!hasIsolated) return;
        }

        let patientDetailsHtml = '';
        if (isolatedClusterCaseIds) {
            patientDetailsHtml = `<div style="margin-top: 12px; max-height: 220px; overflow-y: auto; text-align: left; font-size: 11.5px; background: rgba(0,0,0,0.02); padding: 6px; border-radius: 4px; border: 1px solid rgba(0,0,0,0.05);">`;
            patientDetailsHtml += `<div style="font-weight: bold; margin-bottom: 6px; color: #444; border-bottom: 1px solid #ddd; padding-bottom: 4px;">Patients & Assignments</div>`;
            
            let clusterPatients = c.cases.map(caseId => {
                return { 
                    patient: currentCases.find(f => f.properties.case_id === caseId),
                    route: currentRoutes.find(r => r.case_id === caseId)
                };
            }).filter(item => {
                if (!item.patient) return false;
                const triage = (item.patient.properties.nato_triage || "").toLowerCase();
                let isVisible = false;
                if (showRed && (triage.includes("red") || triage.includes("immediate"))) isVisible = true;
                if (showYellow && (triage.includes("yellow") || triage.includes("delayed"))) isVisible = true;
                if (showGreen && (triage.includes("green") || triage.includes("minimal"))) isVisible = true;
                return isVisible;
            });
            
            clusterPatients.sort((a,b) => {
                const svA = a.patient.properties.nato_triage.toLowerCase().includes("red") ? 3 : (a.patient.properties.nato_triage.toLowerCase().includes("yellow") ? 2 : 1);
                const svB = b.patient.properties.nato_triage.toLowerCase().includes("red") ? 3 : (b.patient.properties.nato_triage.toLowerCase().includes("yellow") ? 2 : 1);
                return svB - svA; 
            });

            if (clusterPatients.length === 0) {
                 patientDetailsHtml += `<div style="color: #888; font-style: italic;">No patients match current filters.</div>`;
            } else {
                clusterPatients.forEach(item => {
                    const p = item.patient.properties;
                    const r = item.route;
                    const tColor = triageColor(p.nato_triage);
                    
                    let destStr = r ? 
                        `<span style="color: #0a7; font-weight: 500;">&rarr; ${r.facility_name} (${r.distance_km.toFixed(1)} km)</span><br><span style="font-size: 10px; color: #888;">${r.reason}</span>` : 
                        `<span style="color: #d97706; font-weight: 500;">&rarr; Unassigned / Pending</span>`;

                    patientDetailsHtml += `
                        <div style="margin-bottom:6px; padding-bottom: 6px; border-bottom: 1px solid rgba(0,0,0,0.05);">
                            <b style="color:${tColor}; font-size: 14px; line-height: 10px;">&bull;</b> 
                            <span style="color: #0078D7; text-decoration: underline; cursor: pointer;" onclick="showPatient(${p.case_id})"><b>Case ${p.case_id}</b></span> &mdash; ${p.nato_triage}<br>
                            ${destStr}
                        </div>`;
                });
            }
            patientDetailsHtml += `</div>`;
        }

        const popupWidth = isolatedClusterCaseIds ? '260px' : '170px';

        const popupHTML = `
          <div style="font:13px/1.25 system-ui,sans-serif; text-align: center; min-width: ${popupWidth};">
            <div style="margin-bottom: 6px; padding-bottom: 4px; border-bottom: 1px solid #eee;">
              <b style="color: #111; font-size: 14px; text-transform: uppercase;">Crisis Cluster</b>
            </div>
            <div style="margin: 8px 0; font-size: 28px; font-weight: 800; color: #111; line-height: 1;">
              ${c.count}
            </div>
            <div style="color: #666; font-size: 11px; text-transform: uppercase; font-weight: 600; margin-bottom: 12px;">
              Filtered Casualties
            </div>
            
            <div style="text-align: left; font-size: 10px; color: #888; text-transform: uppercase; margin-bottom: 4px;">
              Total in Area:
            </div>
            <div style="display: flex; justify-content: space-between; font-weight: bold; font-size: 12px; border-top: 1px solid #eee; padding-top: 6px;">
              <span style="color: #dc2626;" title="Immediate (Red)">T1: ${c.redCount || 0}</span>
              <span style="color: #d97706;" title="Delayed (Yellow)">T2: ${c.yellowCount || 0}</span>
              <span style="color: #16a34a;" title="Minimal (Green)">T3: ${c.greenCount || 0}</span>
            </div>
            ${!isolatedClusterCaseIds ? `
            <div style="margin-top: 10px; text-align: center;">
                <button onclick="isolateClusterByIndex(event, ${index})" style="width: 100%; background: #0078D7; color: white; border: none; padding: 6px; border-radius: 4px; font-weight: bold; cursor: pointer;">Isolate Cluster</button>
            </div>` : patientDetailsHtml}
          </div>
        `;

        let activeCats = [];
        if (showRed && c.redCount > 0) activeCats.push({ color: "#dc2626", count: c.redCount });
        if (showYellow && c.yellowCount > 0) activeCats.push({ color: "#d97706", count: c.yellowCount });
        if (showGreen && c.greenCount > 0) activeCats.push({ color: "#16a34a", count: c.greenCount });

        activeCats.sort((a, b) => a.count - b.count);

        let currentCumulativeCount = 0;
        let previousCoords = null;

        activeCats.forEach((cat, idx) => {
            currentCumulativeCount += cat.count;
            
            let currentRadius = 2000 + (currentCumulativeCount * 800);
            let currentCoords = getCircleCoords(c.lat, c.lon, currentRadius);

            let latlngs = idx === 0 ? [currentCoords] : [currentCoords, [...previousCoords].reverse()];

            let poly = L.polygon(latlngs, {
                color: cat.color,
                fillColor: cat.color,
                fillOpacity: 0.35, 
                weight: 2,
                dashArray: '6, 6',
                interactive: true 
            })
            .bindPopup(popupHTML, { clusterIndex: index, autoPan: false })
            .addTo(demoHotspotsLayer);

            if (idx === 0) clusterPolygons[index] = poly;

            previousCoords = currentCoords;
        });
      });

      enforceZOrder();

      // 2. Immediately reopen the popup if it was open before the redraw
      if (openClusterIndex !== null && clusterPolygons[openClusterIndex]) {
          clusterPolygons[openClusterIndex].openPopup();
      }
    }
    
    function renderRoutes() {
      demoRoutesLayer.clearLayers();
      
      osrmGeneration++;
      isFetchingOsrm = false; 
      osrmQueue = []; 

      if (!document.getElementById("showRoutes").checked) {
          enforceZOrder();
          return;
      }

      const currentZoom = map.getZoom();
      const dynamicWeight = Math.max(0.5, 2 * Math.pow(1.1, currentZoom - 7));
      const clusterMode = document.getElementById("clusterMode").checked;

      const showRed = document.getElementById("triRed").checked;
      const showYellow = document.getElementById("triYellow").checked;
      const showGreen = document.getElementById("triGreen").checked;

      if (clusterMode) {
          let clusterRoutes = {};
          
          currentRoutes.forEach(a => {
              if (isolatedClusterCaseIds && !isolatedClusterCaseIds.has(a.case_id)) return;

              const triage = (a.nato_triage || "").toLowerCase();
              let isVisible = false;
              if (showRed && (triage.includes("red") || triage.includes("immediate"))) isVisible = true;
              if (showYellow && (triage.includes("yellow") || triage.includes("delayed"))) isVisible = true;
              if (showGreen && (triage.includes("green") || triage.includes("minimal"))) isVisible = true;
              
              if (!isVisible) return;
              
              let myClusterIndex = activeClusters.findIndex(c => c.cases.includes(a.case_id));
              
              if (myClusterIndex !== -1) {
                  const key = myClusterIndex + "_" + a.facility_id;
                  if (!clusterRoutes[key]) {
                      clusterRoutes[key] = {
                          cluster: activeClusters[myClusterIndex],
                          facility_id: a.facility_id,
                          facility_name: a.facility_name,
                          facility_coord: a.facility_coord,
                          patients: [],
                          severity: 1
                      };
                  }
                  clusterRoutes[key].patients.push(a);
                  let sev = triage.includes("red") ? 3 : (triage.includes("yellow") ? 2 : 1);
                  clusterRoutes[key].severity = Math.max(clusterRoutes[key].severity, sev);
              }
          });
          
          Object.values(clusterRoutes).forEach(cr => {
              const col = cr.severity === 3 ? "#dc2626" : (cr.severity === 2 ? "#d97706" : "#16a34a");
              const edgeCoord = getEdgeCoord(
                  cr.cluster.lat, cr.cluster.lon, 
                  cr.facility_coord[1], cr.facility_coord[0], 
                  cr.cluster.radiusMeters
              );
              
              const routeCoords = [edgeCoord, [cr.facility_coord[1], cr.facility_coord[0]]];

              const visualLine = L.polyline(routeCoords, { weight: dynamicWeight * 2, opacity: 0.8, color: col, interactive: false }).addTo(demoRoutesLayer);
              
              // Instead of binding the popup immediately, we attach the data so the map click handler can scan it
              const hitLine = L.polyline(routeCoords, { weight: 20, opacity: 0.01, color: "#000", interactive: true }).addTo(demoRoutesLayer);
              hitLine.isHitLine = true;
              hitLine.routeData = cr;
              
              osrmQueue.push({
                  start: [cr.cluster.lon, cr.cluster.lat], 
                  end: cr.facility_coord,
                  visualLine: visualLine,
                  hitLine: hitLine
              });
          });
          
      } else {
          let aggregatedRoutes = {};
          
          currentRoutes.forEach(a => {
            if (isolatedClusterCaseIds && !isolatedClusterCaseIds.has(a.case_id)) return;

            const triage = (a.nato_triage || "").toLowerCase();
            let isVisible = false;
            if (showRed && (triage.includes("red") || triage.includes("immediate"))) isVisible = true;
            if (showYellow && (triage.includes("yellow") || triage.includes("delayed"))) isVisible = true;
            if (showGreen && (triage.includes("green") || triage.includes("minimal"))) isVisible = true;

            if (isVisible) {
              const startKey = `${a.case_coord[0].toFixed(2)},${a.case_coord[1].toFixed(2)}`;
              const endKey = `${a.facility_coord[0].toFixed(3)},${a.facility_coord[1].toFixed(3)}`;
              const key = `${startKey}|${endKey}`;

              if (!aggregatedRoutes[key]) {
                  aggregatedRoutes[key] = {
                      patients: [],
                      facility_name: a.facility_name,
                      facility_coord: a.facility_coord,
                      start_coord: a.case_coord,
                      severity: 1,
                      distance_km: a.distance_km,
                      reason: a.reason
                  };
              }
              aggregatedRoutes[key].patients.push(a);
              let sev = triage.includes("red") ? 3 : (triage.includes("yellow") ? 2 : 1);
              aggregatedRoutes[key].severity = Math.max(aggregatedRoutes[key].severity, sev);
            }
          });

          Object.values(aggregatedRoutes).forEach(g => {
              const col = g.severity === 3 ? "#dc2626" : (g.severity === 2 ? "#d97706" : "#16a34a");
              const baseWeight = Math.min(6, dynamicWeight * (1 + (g.patients.length - 1) * 0.15));

              const routeCoords = [[g.start_coord[1], g.start_coord[0]], [g.facility_coord[1], g.facility_coord[0]]];
              const visualLine = L.polyline(routeCoords, { weight: baseWeight, opacity: 0.8, color: col, interactive: false }).addTo(demoRoutesLayer);
              
              // Instead of binding the popup immediately, we attach the data so the map click handler can scan it
              const hitLine = L.polyline(routeCoords, { weight: 20, opacity: 0.01, color: "#000", interactive: true }).addTo(demoRoutesLayer);
              hitLine.isHitLine = true;
              hitLine.routeData = g;
              
              osrmQueue.push({
                  start: g.start_coord,
                  end: g.facility_coord,
                  visualLine: visualLine,
                  hitLine: hitLine
              });
          });
      }
      
      enforceZOrder();
      processOsrmQueue(osrmGeneration); 
    }

    async function runRouting() {
      const btn = document.getElementById("btnRoute");
      btn.disabled = true;
      try {
        const buffer = document.getElementById("searchBuffer").value;
        const body = {
          triage_filters: ["Immediate (Red)", "Delayed (Yellow)", "Minimal (Green)"],
          max_distance_km: 350,
          allow_outside_area: true,
          max_routes_draw: 500,
          buffer: parseFloat(buffer)
        };
        const r = await fetch("/api/demo/route", {
          method: "POST", headers: { "Content-Type": "application/json" },
          body: JSON.stringify(body)
        });
        const j = await r.json();
        
        document.getElementById("routeSummary").innerHTML = `${j.results.assigned}/${j.results.cases_considered} assigned`;
        currentRoutes = j.routes_for_map || [];

        assignedFacilityIds.clear();
        assignedPatientsByFacility = {};

        currentRoutes.forEach(route => {
            if (route.facility_id) {
                const facId = String(route.facility_id);
                assignedFacilityIds.add(facId);
                
                if (!assignedPatientsByFacility[facId]) {
                    assignedPatientsByFacility[facId] = [];
                }
                assignedPatientsByFacility[facId].push(route);
            }
        });

        renderRoutes();

        const facRes = await fetch(`/api/demo/facilities?buffer=${MAX_LOAD_RADIUS}`);
        const facFc = await facRes.json();
        allFacilitiesFeatures = facFc.features || [];
        
        updateMapDisplay();

      } catch (e) { console.error(e); } finally { btn.disabled = false; }
    }

    window.isolateClusterByIndex = function(e, idx) {
        // Stop the click from passing through the popup to the map polygon
        if (e) e.stopPropagation(); 
        
        const c = activeClusters[idx];
        if (!c) return;
        isolatedClusterCaseIds = new Set(c.cases);
        document.getElementById("btnClearIsolation").style.display = "inline-block";
        
        map.closePopup();
        map._popup = null; // Force clear the popup reference
        
        let lats = [], lons = [];
        currentCases.forEach(f => {
            if (isolatedClusterCaseIds.has(f.properties.case_id)) {
                lons.push(f.geometry.coordinates[0]);
                lats.push(f.geometry.coordinates[1]);
            }
        });
        currentRoutes.forEach(r => {
            if (isolatedClusterCaseIds.has(r.case_id) && r.facility_coord) {
                lons.push(r.facility_coord[0]);
                lats.push(r.facility_coord[1]);
            }
        });

        if (lats.length > 0 && lons.length > 0) {
            const minLat = Math.min(...lats), maxLat = Math.max(...lats);
            const minLon = Math.min(...lons), maxLon = Math.max(...lons);
            map.flyToBounds([[minLat, minLon], [maxLat, maxLon]], { padding: [50, 50], duration: 1.0 });
        }
        
        updateMapDisplay();
        renderCases();
        renderRoutes();
        renderHotspots(true); // Pass true to prevent the popup from re-opening
    };

    function clearIsolation() {
        isolatedClusterCaseIds = null;
        document.getElementById("btnClearIsolation").style.display = "none";
        updateMapDisplay();
        renderCases();
        renderRoutes();
        renderHotspots();
    }

    document.getElementById("btnClearIsolation").addEventListener("click", clearIsolation);
    document.getElementById("searchBuffer").addEventListener("input", updateMapDisplay);
    document.getElementById("hideUnused").addEventListener("change", updateMapDisplay); 
    document.getElementById("btnRoute").addEventListener("click", runRouting);
    document.getElementById("showRoutes").addEventListener("change", renderRoutes);
    document.getElementById("showHotspots").addEventListener("change", renderHotspots);
    
    document.getElementById("clusterMode").addEventListener("change", () => {
        renderCases();
        renderRoutes();
        renderHotspots();
    });
    
    document.getElementById("triRed").addEventListener("change", () => { buildClusters(); renderCases(); renderRoutes(); renderHotspots(); });
    document.getElementById("triYellow").addEventListener("change", () => { buildClusters(); renderCases(); renderRoutes(); renderHotspots(); });
    document.getElementById("triGreen").addEventListener("change", () => { buildClusters(); renderCases(); renderRoutes(); renderHotspots(); });

    document.getElementById("lblRed").addEventListener("click", () => {
      document.getElementById("triRed").checked = true;
      document.getElementById("triYellow").checked = false;
      document.getElementById("triGreen").checked = false;
      buildClusters();
      renderCases(); 
      renderRoutes();
      renderHotspots();
    });

    document.getElementById("lblYellow").addEventListener("click", () => {
      document.getElementById("triRed").checked = false;
      document.getElementById("triYellow").checked = true;
      document.getElementById("triGreen").checked = false;
      buildClusters();
      renderCases(); 
      renderRoutes();
      renderHotspots();
    });

    document.getElementById("lblGreen").addEventListener("click", () => {
      document.getElementById("triRed").checked = false;
      document.getElementById("triYellow").checked = false;
      document.getElementById("triGreen").checked = true;
      buildClusters();
      renderCases(); 
      renderRoutes();
      renderHotspots();
    });

    let isProgrammatic = false;
    
    // Flag when the map is changing zoom so we don't fight user scrolling
    map.on('zoomstart', () => { isProgrammatic = true; });
    
    map.on('zoomend', () => {
      isProgrammatic = true;
      updateMapDisplay();
      renderCases();
      renderRoutes(); 
      renderHotspots();
      setTimeout(() => { isProgrammatic = false; }, 50);
    });

    // Perfectly center the popup without triggering destructive zoomend loops
    map.on('popupopen', function(e) {
        if (isProgrammatic) return;

        // Give the popup a millisecond to render so we get its true physical height
        setTimeout(() => {
            if (!e.popup._map || !e.popup._container) return; 
            
            const popupHeight = e.popup._container.clientHeight;
            const latlng = e.popup.getLatLng();
            const px = map.project(latlng);
            
            // Shift Y upwards by half the popup height + offset for the pointer tip
            px.y -= (popupHeight / 2) + 15;
            
            const targetLatLng = map.unproject(px);
            
            // Smoothly pan so the popup is absolutely dead-center in the viewport
            map.panTo(targetLatLng, { animate: true, duration: 0.4 });
        }, 10);
    });

    loadAllData();
    refreshHealthsitesStatus().then(() => attachHealthsitesLayers());

  </script>
</body>
</html>